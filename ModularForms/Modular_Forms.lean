import Mathlib.NumberTheory.ModularForms.Basic
import Mathlib.NumberTheory.ModularForms.CongruenceSubgroups
import Mathlib.NumberTheory.ModularForms.Identities
import Mathlib.NumberTheory.ModularForms.LevelOne
import Mathlib.NumberTheory.ModularForms.SlashActions
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.Basic
import Mathlib.NumberTheory.ModularForms.QExpansion
import Mathlib.Algebra.DirectSum.Algebra
import Mathlib.NumberTheory.Bernoulli

--import ¬´


-- search with % string

-- case insensitive when typing in lowercase but not when adding upper case, also sensitive to other characters
-- https://leanprover-community.github.io/mathlib4_docs/



--loogle - e.g. to find five lemma
--CategoryTheory.IsIso, CategoryTheoy.Abelian
-- is case sensitive

-- is not sensitive if you use:
-- "abelian", "isiso", "epi"

open EisensteinSeries CongruenceSubgroup
open ModularForm Complex Filter UpperHalfPlane Function
open ModularFormClass
open Complex Topology Manifold --taken from ModularForm.Basic

open scoped Real MatrixGroups CongruenceSubgroup

variable {k : ‚Ñ§} {F : Type*} [FunLike F ‚Ñç ‚ÑÇ] {Œì : Subgroup SL(2, ‚Ñ§)} (n : ‚Ñï) (f : F)
variable{N : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N)
variable {z : ‚Ñç}
#check (eisensteinSeries_MF _ _).toFun
--#check qExpansion 1 (eisensteinSeries_MF hk a).toFun
#check qExpansion_coeff
#check FunLike
#check SlashInvariantFormClass.cuspFunction
--#check CoeFun ‚Ñç (outParam ((eisensteinSeries_MF hk a).toFun z))
#check ‚áë(eisensteinSeries_SIF a k)
#check qExpansion 1 (eisensteinSeries_SIF a k)
#check ModularForm Œì(1) n

local notation "I‚àû" => comap Complex.im atTop
local notation "ùï¢" => Periodic.qParam





variable {U V K : Type*} [Field K] [AddCommMonoid U] [AddCommMonoid V] [Module K U][Module K V]
example (U V : Submodule K V) (h : IsCompl U V) :
  U ‚äî V = ‚ä§ := h.sup_eq_top
#check IsCompl

notation "i" => Complex.I

example {k : ‚Ñï} (a : Fin 2 ‚Üí ZMod 1)  :
{v : Fin 2 ‚Üí ‚Ñ§ | (‚Üë) ‚àò v = a ‚àß IsCoprime (v 0) (v 1)} = {v : Fin 2 ‚Üí ‚Ñ§ |  IsCoprime (v 0) (v 1)} := by
  convert congr_arg _ (Subsingleton.elim a a)


instance fintoprod : (Fin 2 ‚Üí ‚Ñ§) ‚âÉ ‚Ñ§ √ó ‚Ñ§ where
  toFun := fun v => (v 0, v 1)
  invFun := fun v => fun n => if n = 0 then v.1 else v.2
  left_inv := by
    intro v ;
    simp_all only [Fin.isValue] ;
    ext b ;
    split
    next h =>
      subst h
      simp_all only [Fin.isValue]
    next h =>
      have : b = 1 := by sorry
      rw [this]
  right_inv := by
    intro v
    simp_all only [Fin.isValue, ‚ÜìreduceIte, one_ne_zero, Prod.mk.eta]

instance gammaset {k : ‚Ñï} (a : Fin 2 ‚Üí ZMod 1) : gammaSet 1 a = {fintoprod.invFun (x : ‚Ñ§ √ó ‚Ñ§) | x ‚â† 0} where
  toFun := fun v => (v (0 : Fin 2), v (1 : Fin 2 ))
  invFun := fun v => fun x => if x = 0 then v 0 else v 1
  left_inv := sorry
  right_inv := sorry


lemma eisensteinSeries_expand {k : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
eisensteinSeries a k  = fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k:‚Ñ§)) + ‚àë' y : ‚Ñï+, ‚àë' x : ‚Ñ§, (y * (z : ‚ÑÇ) + x) ^ (-(k:‚Ñ§)):= by
  ext z
  unfold eisensteinSeries eisSummand
  simp_all only [PNat.val_ofNat, Fin.isValue, zpow_neg, zpow_natCast]
  unfold tsum
  apply gammaset
  sorry


lemma rw_of_cotangent {k : ‚Ñï } (hk : 3 ‚â§ k) :
 ‚àë' x : ‚Ñ§, ((z:‚ÑÇ) + (x : ‚ÑÇ))^(-(k : ‚Ñ§)) =
 (2*œÄ*i)^k* (Nat.factorial (k - 1) )^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, Complex.exp (2*œÄ*i*d*z) := sorry

theorem eisensteinSeries_eq_qExpansion {k : ‚Ñï } (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
eisensteinSeries a k =  fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+,
‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) := by
  rw [eisensteinSeries_expand hk a]
  ext (z: ‚Ñç)
  have {y : ‚Ñï+}: ‚àë' x : ‚Ñ§, (y * (z:‚ÑÇ) + (x : ‚ÑÇ))^(-(k : ‚Ñ§)) = (2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, Complex.exp (2*œÄ*i*d*y*(z:‚ÑÇ)) := by
    have : ‚àÉ s : ‚Ñç, (s : ‚ÑÇ) = y * z := sorry
    rcases this with ‚ü®s, h‚ü©
    simp_rw [mul_assoc (2 * œÄ * i * _)]
    rw [‚Üê h, rw_of_cotangent hk]
  simp only [this]
  have : ‚àë' (y : ‚Ñï+), ‚àë' (d : ‚Ñï+), cexp (2*œÄ*i*d*y*z) = ‚àë' (d : ‚Ñï+) (m : {s : ‚Ñï+ | s ‚à£ d}), m^(k-1) * cexp (2*œÄ*i*d*z) := sorry
  congr
  rw [tsum_mul_left]
  rw [this]

lemma isthisuseful {d : ‚Ñï+} : (fun z ‚Ü¶ Complex.exp (2*œÄ*i*d*z)) = Function.Periodic.qParam (1/d) := by
  unfold Function.Periodic.qParam
  simp
  ring_nf
lemma isthisuseful2 {d : ‚Ñï+} : Complex.exp (2*œÄ*i*d*z) = Function.Periodic.qParam (1/d) z := by unfold Function.Periodic.qParam; simp; ring_nf
lemma isthisuseful3 {d : ‚Ñï} : Complex.exp (2*œÄ*i*d*z) = Function.Periodic.qParam (1/d) z := by unfold Function.Periodic.qParam; simp; ring_nf


lemma nnamme {d : ‚Ñï+} : (fun z ‚Ü¶ Complex.exp (2*œÄ*i*d*z)) = Function.Periodic.cuspFunction (1/d : ‚Ñù) (fun z ‚Ü¶ z) := by
  rw [isthisuseful]
  ext x;
  unfold Periodic.cuspFunction Periodic.invQParam limUnder update
  simp
  refine eq_ite_iff.mpr ?_
  constructor
  constructor
  swap
  rw [lim]
  --unfinished




lemma eisenstein_sif_is {k : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+))  :
  eisensteinSeries_SIF a k = fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, ‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) := by
  ext z
  rw [eisensteinSeries_SIF_apply, eisensteinSeries_eq_qExpansion hk]

lemma eisensteinSeries_MF_is {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
(eisensteinSeries_MF hk a).toFun = fun z : ‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, ‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) := by apply eisenstein_sif_is _ a ; norm_cast at hk

--THIS ONE IS BETTER
lemma eisensteinSeries_MF_is' {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
(eisensteinSeries_MF hk a) = fun z : ‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, ‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) := by apply eisenstein_sif_is _ a ; norm_cast at hk

open DirectSum
open scoped DirectSum

#check CuspForm.zero_at_infty'

lemma bdd_at_infty_of_zero_at_infty (f : CuspForm Œì k) : ‚àÄ A : SL(2, ‚Ñ§), IsBoundedAtImInfty (f ‚à£[k] A) := by
  intro A
  have h‚ÇÅ : IsZeroAtImInfty (f ‚à£[k] A) := by
    apply CuspForm.zero_at_infty' f
  rw [UpperHalfPlane.isBoundedAtImInfty_iff]
  rw [UpperHalfPlane.isZeroAtImInfty_iff] at h‚ÇÅ
  use 1
  apply h‚ÇÅ _ _
  linarith

--they showed this already for ModularFormClass F Œì k with F œÄ type
instance coe_CuspForm (f : CuspForm Œì k) : ModularForm Œì k where
  toFun := f
  slash_action_eq' := by apply SlashInvariantForm.slash_action_eq'
  holo' := by apply CuspForm.holo'
  bdd_at_infty' := by apply bdd_at_infty_of_zero_at_infty

def coe_Hom' : CuspForm Œì k  ‚Üí+ ModularForm Œì k where
  toFun := coe_CuspForm
  map_zero' := by rfl
  map_add' := by intro f g ; rfl

def coe_Hom : CuspForm Œì k ‚Üí[‚ÑÇ] ModularForm Œì k where
  toFun := coe_Hom'
  map_smul' := by intro c f ; rfl

instance CuspForm_Subspace (Œì : Subgroup SL(2, ‚Ñ§)) (k : ‚Ñ§): Submodule ‚ÑÇ (ModularForm Œì k) where
  carrier := Set.range coe_Hom
  add_mem' := by
    intro f g h h‚ÇÅ
    simp ; simp at h ; simp at h‚ÇÅ
    rcases h with ‚ü®f1, hf‚ü© ; rcases h‚ÇÅ with ‚ü®g1, hg‚ü©
    use (f1 + g1)
    rw [‚Üê hf,‚Üê hg]
    rfl
  zero_mem' := by simp ; use 0 ; rfl
  smul_mem' := by
    intro c f h
    simp ; simp at h
    rcases h with ‚ü®g, h‚ÇÅ‚ü©; use (c ‚Ä¢ g)
    simp ; rw [h‚ÇÅ]

lemma coee {f : CuspForm Œì k} :
coe_Hom f ‚àà CuspForm_Subspace Œì k := by tauto

#check Classical.choose
lemma coe_hom_inj {f g : CuspForm Œì k} : (coe_Hom f = coe_Hom g) ‚Üí f = g  := by intro h ; unfold coe_Hom coe_Hom' at *; sorry

lemma coe_hom_surj (f : ModularForm Œì k) (finCuspSub : f ‚àà (CuspForm_Subspace Œì k)) :
‚àÉ g : CuspForm Œì k, f = coe_Hom g := by
  have finCuspSub: f ‚àà Set.range coe_Hom := by tauto
  have : (CuspForm_Subspace Œì k).carrier ‚äÜ Set.range coe_Hom := by rfl
  rw [Set.subset_range_iff_exists_image_eq] at this
  obtain ‚ü®t, tis‚ü© := this
  have h‚ÇÅ: (CuspForm_Subspace Œì k).carrier = Set.range ‚áëcoe_Hom := rfl
  rw [h‚ÇÅ] at tis
  rw [‚Üê tis] at finCuspSub
  unfold Set.image at *
  have h‚ÇÇ : ‚àÉ a ‚àà t, coe_Hom a = f := by apply finCuspSub
  obtain ‚ü®a, aint‚ü© := h‚ÇÇ
  use a
  tauto

instance isom (Œì : Subgroup SL(2, ‚Ñ§)) (k : ‚Ñ§) :
  (CuspForm Œì k) ‚âÉ‚Çó[‚ÑÇ] CuspForm_Subspace Œì k where
    toFun := fun f => ‚ü®coe_Hom f , coee‚ü©
    map_add' := by intro x y; tauto
    map_smul' := by intro c x ; tauto
    invFun := fun ‚ü®f,finCusp‚ü© => Exists.choose (coe_hom_surj f finCusp)
    left_inv := by
      intro x; simp;
      convert Classical.choose_eq _  ; constructor ;
      intro h‚ÇÅ ; apply coe_hom_inj ; symm ; apply h‚ÇÅ
      intro h‚ÇÅ ; rw [h‚ÇÅ]
    right_inv := by
      intro x ; simp
      convert Classical.choose_eq _ ; simp ;
      sorry
-- ## Q-expansion theorems

--names are identical to mathlib, but okay for now since I havent imported q_expansions apparently
theorem periodic_comp_ofComplex (n:‚Ñï) (f : SlashInvariantForm Œì(n) k) :
    Periodic (f ‚àò ofComplex) n := by
  intro w
  by_cases hw : 0 < im w
  ¬∑ have : 0 < im (w + n) := by simp only [add_im, natCast_im, add_zero, hw]
    simp only [comp_apply, ofComplex_apply_of_im_pos this, ofComplex_apply_of_im_pos hw]
    convert SlashInvariantForm.vAdd_width_periodic n k 1 f ‚ü®w, hw‚ü© using 2
    simp only [Int.cast_one, mul_one, UpperHalfPlane.ext_iff, coe_mk_subtype, coe_vadd,
      ofReal_natCast, add_comm]
  ¬∑ have : im (w + n) ‚â§ 0 := by simpa only [add_im, natCast_im, add_zero, not_lt] using hw
    simp only [comp_apply, ofComplex_apply_of_im_nonpos this,
      ofComplex_apply_of_im_nonpos (not_lt.mp hw)]

theorem zero_at_infty_comp_ofComplex (f : CuspForm Œì k) : ZeroAtFilter I‚àû (f ‚àò ofComplex) := by
  simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
    using (CuspForm.zero_at_infty' f 1).comp tendsto_comap_im_ofComplex

theorem exp_decay_atImInfty [NeZero n] (f : CuspForm Œì(n) k) :
    f =O[atImInfty] fun œÑ ‚Ü¶ Real.exp (-2 * œÄ * œÑ.im / n) := by
  simpa only [neg_mul, comp_def, ofComplex_apply, coe_im] using
    ((periodic_comp_ofComplex n (f : SlashInvariantForm Œì(n) k)).exp_decay_of_zero_at_inf
      (mod_cast (Nat.pos_iff_ne_zero.mpr (NeZero.ne _)))
      (eventually_of_mem (preimage_mem_comap (Ioi_mem_atTop 0))
        fun _ ‚Ü¶ differentiableAt_comp_ofComplex f)
      (zero_at_infty_comp_ofComplex f)).comp_tendsto tendsto_coe_atImInfty

-- ## Back to Eisenstein series
noncomputable def pow1 (k : ‚Ñï)  := fun x : ‚Ñï ‚Ü¶ 2 * ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§))
noncomputable def pow2 (k : ‚Ñï)  := fun x : ‚Ñï ‚Ü¶ (2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * (‚àë' m : {s : ‚Ñï+ | (s : ‚Ñï) ‚à£ x}, (m : ‚Ñï)^(k-1))-- * ùï¢ x‚Åª¬π z-- Complex.exp (2*œÄ*i*x*z)

--def func : Fin 2 ‚Üí ZMod (1:‚Ñï+) := (fun (_ : Fin 2) ‚Ü¶ 0 )
--variable (hkk : 3 ‚â§ (4 : ‚Ñ§))
--#eval Periodic.cuspFunction 1 (‚áë(@eisensteinSeries_MF 4 (1:‚Ñï+) (by linarith) func) ‚àò ‚ÜëofComplex)

example {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
 (Periodic.cuspFunction 1 (‚áë(eisensteinSeries_MF hk a) ‚àò ‚ÜëofComplex))  := sorry

lemma  zeta_HasSum_eq_bernoulli {k : ‚Ñï} :
HasSum (pow1 k)  (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)) := by sorry

lemma eisenstein_q_expansion {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
  qExpansion 1 (eisensteinSeries_MF hk a)  = .mk (pow1 k) +.mk ( pow2 k) := by
  unfold pow1 pow2 qExpansion SlashInvariantFormClass.cuspFunction
  unfold iteratedDeriv
  simp_all only [Nat.cast_one, PNat.val_ofNat, zpow_neg, zpow_natCast, Int.reduceNeg, zpow_one, Set.coe_setOf,
    Set.mem_setOf_eq]

  rw [eisensteinSeries_MF_is hk a] --maybe add another version of the above for this coercion?
  --unfold Periodic.cuspFunction --iteratedDeriv iteratedFDeriv
  --simp
  ext n
  simp only [iteratedDeriv_eq_iterate, Periodic.eq_cuspFunction]
  unfold Periodic.cuspFunction
  simp_rw [isthisuseful2,isthisuseful3]
  sorry
  --simp
  --apply deriv_add
  --simp only [ofComplex_apply]
  --simp_rw [comp_mul_left]
  /-
  convert Function.Periodic.cuspFunction_zero_eq_limUnder_nhds_ne (1 : ‚Ñù) (@comp ‚ÑÇ ‚Ñç ‚ÑÇ
  (fun z ‚Ü¶
    2 * ‚àë' (x : ‚Ñï+), ‚Üë‚Üëx ^ (-‚Üëk) +
      (-2 * ‚ÜëœÄ * i) ^ k * ‚Üë(k - 1).factorial ^ (-1) *
        ‚àë' (d : ‚Ñï+) (m : ‚Üë{s | s ‚à£ ‚Üëd}), ‚Üë‚Üëm ^ (k - 1) * cexp (2 * ‚ÜëœÄ * i * ‚Üë‚Üëd * ‚Üëz))
  ‚ÜëofComplex )
  simp
  --ring_nf
  --simp
  -/



lemma Eisenstein_0th_coeff_one {k : ‚Ñ§} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
PowerSeries.coeff ‚ÑÇ 0 (qExpansion n (eisensteinSeries_MF hk a)) = 1 := sorry

#check bernoulli'

lemma Eisenstein_series_ne_zero  {k : ‚Ñ§} {N : ‚Ñï+} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N) :
 qExpansion N (eisensteinSeries_MF hk a) ‚â† 0 := by
  intro h
  rw [‚Üê PowerSeries.forall_coeff_eq_zero] at h
  have h‚ÇÅ : PowerSeries.coeff ‚ÑÇ 0 (qExpansion N (eisensteinSeries_MF hk a)) = 1 := by exact Eisenstein_0th_coeff_one N hk a
  rw [h 0] at h‚ÇÅ
  have : 0 = (1:‚ÑÇ) ‚Üí False := by simp
  apply this ; apply h‚ÇÅ

lemma Eisenstein_series_not_zero {k : ‚Ñ§} {N : ‚Ñï+} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N) :
  eisensteinSeries_MF hk a ‚â† 0 := by
  intro h
  have h‚ÇÅ : qExpansion N (eisensteinSeries_MF hk a) = 0 := by
    rw [h]
    ext j
    simp
    unfold qExpansion
    simp
    right
    unfold SlashInvariantFormClass.cuspFunction
    rw [Periodic.cuspFunction_zero_of_zero_at_inf]
    sorry
  apply Eisenstein_series_ne_zero
  exact h‚ÇÅ

open Classical


lemma eisensteinSeries_has_qExpansion_sum (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)):
qExpansion 1 (eisensteinSeries_MF hk a) =
.mk fun m: ‚Ñï => (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ m ‚Ä¢ ùï¢ 1 z ^ m := by
  ext m
  simp


theorem qExpansion_unique {f g : ModularForm Œì k} : qExpansion 1 f = qExpansion 1 g ‚Üî f = g := by sorry



lemma Zeta_function_eq {k : ‚Ñï} : ‚àë' (x : ‚Ñï+), (x : ‚ÑÇ) ^ (-(k : ‚Ñ§)) = - (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k) := by
  sorry
lemma i_pow_k_of_even {k m: ‚Ñï} (keven:  k = 2 * m) : i ^ k = (- 1) ^ m := sorry

lemma i_pow_k_of_even' {k m: ‚Ñï} (keven:  k = 2 * m) : (2 * œÄ * i) ^ k = (- 1) ^ m * (2 * œÄ ) ^ k := sorry

theorem eisensteinSeries_apply_zero {k: ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)):
    SlashInvariantFormClass.cuspFunction 0 (eisensteinSeries_MF hk a) 0 = - (2 * œÄ * i) ^ k * (bernoulli' k) / (Nat.factorial k) := by
    sorry

lemma eq_CuspFunction {f : ModularForm Œì(1) k} : f.toFun = fun œÑ : ‚Ñç ‚Ü¶ SlashInvariantFormClass.cuspFunction 1 f (ùï¢ 1 œÑ) := sorry
--#check fun i, p i \smul continuous_linear_map.pi_algebra

open PowerSeries
noncomputable instance FPowerSeries_of_PowerSeries : ‚ÑÇ‚ü¶X‚üß ‚Üí‚Çó[‚ÑÇ] FormalMultilinearSeries ‚ÑÇ ‚ÑÇ ‚ÑÇ where
  toFun œà := fun m ‚Ü¶ œà.coeff ‚ÑÇ m ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m _
  map_add' := by intro œà œÜ ; simp ; ext m h‚ÇÅ ; ring_nf ; simp ; ring_nf
  map_smul' := by
    intro c œà ; simp_all only [map_smul, smul_eq_mul, RingHom.id_apply] ;
    ext m h‚ÇÅ ;
    simp_all only [ContinuousMultilinearMap.smul_apply, ContinuousMultilinearMap.mkPiAlgebraFin_apply, smul_eq_mul,
      FormalMultilinearSeries.smul_apply]
    ring_nf

@[simp]
lemma coe_inj :  Injective FPowerSeries_of_PowerSeries := by
  intro œà œÜ h
  simp [FPowerSeries_of_PowerSeries] at h
  sorry

noncomputable instance FPowerSeries_of_tsum : ‚ÑÇ‚ü¶X‚üß ‚Üí‚Çó[‚ÑÇ] FormalMultilinearSeries ‚ÑÇ ‚ÑÇ ‚ÑÇ where
  toFun œà := fun m ‚Ü¶ œà.coeff ‚ÑÇ m ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m _
  map_add' := by intro œà œÜ ; simp ; ext m h‚ÇÅ ; ring_nf ; simp ; ring_nf
  map_smul' := by
    intro c œà ; simp_all only [map_smul, smul_eq_mul, RingHom.id_apply] ;
    ext m h‚ÇÅ ;
    simp_all only [ContinuousMultilinearMap.smul_apply, ContinuousMultilinearMap.mkPiAlgebraFin_apply, smul_eq_mul,
      FormalMultilinearSeries.smul_apply]
    ring_nf

lemma qExpansion_eisensteinSeries_as_FPowerSeries {k: ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) = (fun (m : ‚Ñï) ‚Ü¶ (2 * ((m : ‚ÑÇ)) ^(-(k : ‚Ñ§))) ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m _) +
(fun (x : ‚Ñï) ‚Ü¶ ((2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * (‚àë' m : {s : ‚Ñï+ | (s : ‚Ñï) ‚à£ x}, (m: ‚Ñï)^(k-1)) * ùï¢ x‚Åª¬π z) ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ x _):= by
  ext l h
  simp_all only [PNat.val_ofNat, FormalMultilinearSeries.apply_eq_prod_smul_coeff, smul_eq_mul, zpow_neg,
    zpow_natCast, Int.reduceNeg, zpow_one, Set.coe_setOf, Set.mem_setOf_eq, mul_eq_mul_left_iff]
  left
  sorry

lemma modularForms_is_periodic {œÑ : ‚ÑÇ} {f : ModularForm Œì(1) k} : f (ofComplex (œÑ + 1)) = f (ofComplex œÑ) := by sorry

lemma modularForms_is_differentiable {f : ModularForm Œì(1) k} : ‚àÄ·∂† (z : ‚ÑÇ) in I‚àû, DifferentiableAt ‚ÑÇ (‚áëf ‚àò ‚ÜëofComplex) z := by
  sorry
lemma modularForms_is_BoundedAtFilter {f : ModularForm Œì(1) k} : I‚àû.BoundedAtFilter (‚áëf ‚àò ‚ÜëofComplex) := by sorry

--lemma eq_multilin : f = qExpansionFormalMultilinearSeries 1 f
lemma modularForm_TendsTo_Filter_at_zero {f : ModularForm Œì(1) k} (hyp : (coeff ‚ÑÇ 0) (qExpansion 1 f) = 0 ): Filter.Tendsto f (Filter.comap UpperHalfPlane.im Filter.atTop) (ùìù 0) := by
      --suffices Tendsto (Function.Periodic.cuspFunction 1 (f.toFun ‚àò ofComplex)) (ùìù[‚â†] 0) (ùìù <| Function.Periodic.cuspFunction 1 (f.toFun ‚àò ofComplex) 0) by
      --  simpa only [Function.comp_def, Function.Periodic.eq_cuspFunction _ _] using this.comp (Function.Periodic.qParam_tendsto _)
      convert @Function.Periodic.tendsto_at_I_inf 1 (‚áëf ‚àò ofComplex) _ _ _ _
      ¬∑ ext F
        constructor
        ¬∑ intro h
          simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
            using (h).comp tendsto_comap_im_ofComplex
        ¬∑ intro h‚ÇÅ s h‚ÇÇ
          obtain ‚ü®t, h‚ÇÉ‚ü© := h‚ÇÅ h‚ÇÇ
          use t
          simp_all only [Nat.cast_one, mem_atTop_sets, ge_iff_le, true_and]
          obtain ‚ü®left, right‚ü© := h‚ÇÉ
          obtain ‚ü®w, h_1‚ü© := left
          convert right
          simp_all only [coeff_zero_eq_constantCoeff, iff_true]
          intro r h‚ÇÉ

          simp_all only [Set.mem_preimage]
          refine Set.mem_preimage.mp ?_
          have thing: (r : ‚ÑÇ)  ‚àà (Complex.im ‚Åª¬π' t) := by apply h‚ÇÉ
          have thing1  : (r : ‚ÑÇ) ‚àà ‚áëf ‚àò ‚ÜëofComplex ‚Åª¬π' s := by apply right; convert thing
          convert thing1
          simp_all only [SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe, Set.mem_preimage, coe_im,
            comp_apply, ofComplex_apply]
          /-
          intro h‚ÇÅ s h‚ÇÇ
          obtain ‚ü®t, h‚ÇÉ‚ü© := h‚ÇÅ h‚ÇÇ
          use t
          simp_all only [Nat.cast_one, mem_atTop_sets, ge_iff_le, true_and]
          obtain ‚ü®left, right‚ü© := h‚ÇÉ
          obtain ‚ü®w, h_1‚ü© := left
          convert right
          simp_all only [coeff_zero_eq_constantCoeff, iff_true]
          intro r h‚ÇÉ

          simp_all only [Set.mem_preimage]
          refine Set.mem_preimage.mp ?_
          have thing: (r : ‚ÑÇ)  ‚àà (Complex.im ‚Åª¬π' t) := by apply h‚ÇÉ
          have thing1  : (r : ‚ÑÇ) ‚àà ‚áëf ‚àò ‚ÜëofComplex ‚Åª¬π' s := by apply right; convert thing
          convert thing1
          simp_all only [SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe, Set.mem_preimage, coe_im,
            comp_apply, ofComplex_apply]
          -/
      ¬∑ unfold qExpansion at hyp
        simp_all only [coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one, iteratedDeriv_zero, one_mul]
        unfold SlashInvariantFormClass.cuspFunction at hyp
        convert hyp
        simp_all only [Nat.cast_one]
        simp_all only [Nat.cast_one]
        --simp_all only [coeff_zero_eq_constantCoeff, SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe]
      ¬∑ simp
      ¬∑ simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, Periodic, ofReal_one, comp_apply]
        intro x
        apply modularForms_is_periodic
        --convert f.slash_action_eq' ‚ü®!![1,1;0,1] , by norm_num [Matrix.det_fin_two_of]‚ü© _
        --sorry
      ¬∑ apply modularForms_is_differentiable

       -- apply Function.Periodic.differentiableAt_cuspFunction_zero

        --convert f.holo'
        --simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, eventually_comap, eventually_atTop, ge_iff_le,
        --  toSlashInvariantForm_coe]
        --apply Iff.intro
        --¬∑ intro a
        --  obtain ‚ü®w, h_1‚ü© := a
        --  sorry

      --  ¬∑ intro a
      --    sorry
      ¬∑ apply modularForms_is_BoundedAtFilter


theorem zeroAtInfty_iff_CuspForm {f : ModularForm Œì(1) k} : (‚àÄ A : SL(2, ‚Ñ§), IsZeroAtImInfty (f.toFun ‚à£[(k : ‚Ñ§)] A)) ‚Üî (qExpansion 1 f).coeff ‚ÑÇ 0 = 0 := by
  constructor
  ¬∑ intro h
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul]
    unfold IsZeroAtImInfty ZeroAtFilter at h
    unfold SlashInvariantFormClass.cuspFunction
    apply Periodic.cuspFunction_zero_of_zero_at_inf
    simp
    simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
    using (h 1).comp tendsto_comap_im_ofComplex
  ¬∑ intro h
    have cloneh : (coeff ‚ÑÇ 0) (qExpansion 1 f) = 0 := h
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul] at h
    intro A
    rw [f.slash_action_eq' A]
    unfold SlashInvariantFormClass.cuspFunction at h
    rw [Function.Periodic.cuspFunction_zero_eq_limUnder_nhds_ne] at h
    unfold IsZeroAtImInfty
  /-
    have : Filter.Tendsto f (Filter.comap UpperHalfPlane.im Filter.atTop) (nhds (Periodic.cuspFunction 1 (f ‚àò ofComplex) 0)) := by
      -- If f is periodic, and holomorphic and bounded near I‚àû,
      --then it tends to a limit at I‚àû, and this limit is the value of its cusp function at 0.
      convert Function.Periodic.tendsto_at_I_inf _ _ _ _ --## replace with lemma
      ¬∑ ext F
        constructor
        ¬∑ intro h
          simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
            using (h).comp tendsto_comap_im_ofComplex
        ¬∑ intro h‚ÇÅ s h‚ÇÇ
          obtain ‚ü®t, h‚ÇÉ‚ü© := h‚ÇÅ h‚ÇÇ
          use t
          simp_all only [Nat.cast_one, mem_atTop_sets, ge_iff_le, true_and]
          obtain ‚ü®left, right‚ü© := h‚ÇÉ
          obtain ‚ü®w, h_1‚ü© := left
          convert right
          simp_all only [coeff_zero_eq_constantCoeff, iff_true]
          intro r h‚ÇÉ

          simp_all only [Set.mem_preimage]
          refine Set.mem_preimage.mp ?_
          have thing: (r : ‚ÑÇ)  ‚àà (Complex.im ‚Åª¬π' t) := by apply h‚ÇÉ
          have thing1  : (r : ‚ÑÇ) ‚àà ‚áëf ‚àò ‚ÜëofComplex ‚Åª¬π' s := by apply right; convert thing
          convert thing1
          aesop
      ¬∑ linarith
      ¬∑ simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, Periodic, ofReal_one, comp_apply]
        intro x
        apply modularForms_is_periodic
      ¬∑ apply modularForms_is_differentiable
        --simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, eventually_comap, eventually_atTop, ge_iff_le]

        --apply mdifferentiableAt_iff_differentiableAt.mp
        --convert f.holo' --apply Function.Periodic.differentiableAt_cuspFunction_zero
        --simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, eventually_comap, eventually_atTop, ge_iff_le,
        --  toSlashInvariantForm_coe]
        --apply Iff.intro

      ¬∑ apply modularForms_is_BoundedAtFilter--intro a
        --obtain ‚ü®w, h_1‚ü© := a
  -/
    simp_all only [Nat.cast_one, SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe]
    unfold ZeroAtFilter atImInfty
    convert modularForm_TendsTo_Filter_at_zero cloneh
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul] at cloneh
    rw [Gamma_one_top]
    simp only [Subgroup.mem_top]


    /-
    unfold SlashInvariantFormClass.cuspFunction at cloneh

    convert cloneh
    rw [cloneh]
    constructor
    ¬∑ tauto
    ¬∑ intro hyp
      have : Œì(1) = SL(2,‚Ñ§) := by
-/

theorem qExpansionff {f g : ModularForm Œì(1) k} : qExpansion 1 f = qExpansion 1 g ‚Üî SlashInvariantFormClass.cuspFunction 1 g =  SlashInvariantFormClass.cuspFunction 1 f := by
  constructor
  ¬∑ intro h

lemma lemma1 {f g : ModularForm Œì(1) k} {h : qExpansion 1 f = qExpansion 1 g}:  qExpansionFormalMultilinearSeries 1 f = qExpansionFormalMultilinearSeries 1 g := by
      unfold qExpansionFormalMultilinearSeries
      rw [h]

lemma lemma2 {f g : ModularForm Œì(1) k} {h : qExpansion 1 f = qExpansion 1 g}: HasFPowerSeriesOnBall (SlashInvariantFormClass.cuspFunction 1 g) (qExpansionFormalMultilinearSeries 1 f) 0 1 := by
      rw [lemma1]
      apply hasFPowerSeries_cuspFunction 1 g
      apply h



theorem qExpansion_congr {f g : ModularForm Œì(1) k}: qExpansion 1 f = qExpansion 1 g  ‚Üî ‚àÄ n : ‚Ñï, (qExpansion 1 f).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n = (qExpansion 1 g).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  constructor
  ¬∑ intro h n
    simp only [smul_eq_mul, mul_eq_mul_right_iff, pow_eq_zero_iff', ne_eq]
    left
    rw [h]
  ¬∑ intro h
    ext n
    simp only [smul_eq_mul, mul_eq_mul_right_iff, pow_eq_zero_iff', ne_eq] at h
    have : ùï¢ 1 ‚Üëz ‚â† 0 := by
      intro h‚ÇÅ
      unfold Periodic.qParam at h‚ÇÅ
      simp_all only [ofReal_one, div_one, exp_ne_zero]
    have : (coeff ‚ÑÇ n) (qExpansion 1 f) = (coeff ‚ÑÇ n) (qExpansion 1 g) := by
      convert h n
      simp_all only [false_and, or_false, ne_eq]
    apply this






lemma obvsthing {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n) ((eisensteinSeries_MF hk a) z) := by
 convert hasSum_qExpansion 1 (eisensteinSeries_MF hk a) z
 norm_cast

lemma obvsthing2 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  ((eisensteinSeries_MF hk a) z) = ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  symm
  apply HasSum.tsum_eq (obvsthing hk a keven)

lemma obvsthing3 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+,
‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) = ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  symm
  rw [‚Üê obvsthing2 hk a keven]
  rw [eisensteinSeries_MF_is' hk a]

lemma obvsthing4 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
(- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)
  + (2 * œÄ * i) ^ k * (k - 1).factorial ^ (-(1 : ‚Ñ§)) *
   ‚àë' (d : ‚Ñï+) (m : {s | s ‚à£ d}), ((m : ‚Ñï+) : ‚ÑÇ) ^ (k - 1) ‚Ä¢ ùï¢ 1 z ^ (d:‚Ñï) )=
    ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  sorry

noncomputable def eisensteincoeff {k : ‚Ñï} : ‚Ñï ‚Üí ‚ÑÇ :=
  fun n => if n = 0 then (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k))
  else (2 * œÄ * i) ^ k * (k - 1).factorial ^ (-(1 : ‚Ñ§)) * ‚àë' (m : {s | s ‚à£ n }), (m : ‚ÑÇ) ^ (k - 1)

lemma eisensteinSeries_is_tsum_eisensteincoeff {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§))
 (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 eisensteinSeries_MF hk a z = (‚àë' (n : ‚Ñï), @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n) := by sorry

lemma obvsthing7 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (@eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n)) ((eisensteinSeries_MF hk a) z) := by
  rw [eisensteinSeries_is_tsum_eisensteincoeff]
  unfold HasSum Tendsto
  intro S h‚ÇÅ
  rename_i x
  subst x
  simp_all only [Nat.cast_mul, Nat.cast_ofNat, smul_eq_mul, mem_map, mem_atTop_sets, ge_iff_le, Finset.le_eq_subset,
    Set.mem_preimage]
  sorry
  assumption


open SlashInvariantFormClass

theorem coeffiecients_cancel {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) : ‚àÄ (n : ‚Ñï), (@eisensteincoeff k n) -
((qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n) = 0 := by

  sorry

noncomputable def eisensteinFormalMultilinearSeries {k : ‚Ñï} : FormalMultilinearSeries ‚ÑÇ ‚ÑÇ ‚ÑÇ :=
  fun m ‚Ü¶ @eisensteincoeff k m ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m ‚ÑÇ

lemma hasFPowerSeries_eisen {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)  :
    HasFPowerSeriesOnBall (cuspFunction 1 (eisensteinSeries_MF hk a)) (@eisensteinFormalMultilinearSeries k) 0 1 := by
  --refine ‚ü®qExpansionFormalMultilinearSeries_radius n f, zero_lt_one, fun hy ‚Ü¶ ?_‚ü©
  --rw [EMetric.mem_ball, edist_zero_right, enorm_eq_nnnorm, ENNReal.coe_lt_one_iff,
  --  ‚Üê NNReal.coe_lt_one, coe_nnnorm] at hy
  --simpa [qExpansionFormalMultilinearSeries] using hasSum_qExpansion_of_abs_lt n f hy
  sorry

theorem EisensteinserieshasFPsum  {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 cuspFunction 1 (eisensteinSeries_MF hk a) q = (@eisensteinFormalMultilinearSeries k).sum q := by
  apply HasFPowerSeriesOnBall.unique (hasFPowerSeries_eisen hk a keven)
  convert FormalMultilinearSeries.hasFPowerSeriesOnBall (@eisensteinFormalMultilinearSeries k) _
  sorry --small things like radius arguments left
  sorry
  sorry

theorem EisensteinserieshasFPsum2 {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  cuspFunction 1 (eisensteinSeries_MF hk a) q  =
  (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a)).sum q := by
  sorry

lemma Sumequiv {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  (@eisensteinFormalMultilinearSeries k).sum = (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a)).sum := by
  ext q
  rw [‚Üê EisensteinserieshasFPsum hk a keven, ‚Üê EisensteinserieshasFPsum2 hk a keven]



theorem TheFPSeriesagree {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  @eisensteinFormalMultilinearSeries k = qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) := by

  --apply FormalMultilinearSeries.ext
  sorry

lemma TheFPSeriesagree2 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)  :
 ‚àÄ (n : ‚Ñï), @eisensteinFormalMultilinearSeries k n =
 qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) n := by
  apply FormalMultilinearSeries.ext_iff.mp
  apply TheFPSeriesagree hk a keven





theorem mkPiAlgebra_eq_iff  (R : Type u) (n : ‚Ñï) (A : Type u_1) [CommSemiring R] [Semiring A]
  [Algebra R A] [TopologicalSpace A] [ContinuousMul A] {z‚ÇÅ z‚ÇÇ : R} :
    z‚ÇÅ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin R n A  = z‚ÇÇ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin R n A ‚Üî
      z‚ÇÅ = z‚ÇÇ := by
    apply Iff.intro
    ¬∑ intro a
      apply smul_left_injective
      have :  (z‚ÇÅ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin R n A) - (z‚ÇÇ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin R n A )= 0 :=

    ¬∑ intro a
      subst a
      simp_all only


theorem newext {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
‚àÄ (n : ‚Ñï), @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n = (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  have : (qExpansion 1 (eisensteinSeries_MF hk a)) = (qExpansion 1 (eisensteinSeries_MF hk a)) := by tauto
  rw [@qExpansion_congr k z] at this
  have IMPORTANT : @eisensteinFormalMultilinearSeries k = qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a):= by
    apply TheFPSeriesagree hk a keven
  rw [FormalMultilinearSeries.ext_iff] at IMPORTANT
  unfold eisensteinFormalMultilinearSeries qExpansionFormalMultilinearSeries at IMPORTANT
  --simp only [instHSMul,SMul.smul_eq_hSMul] at IMPORTANT
  simp_rw [mkPiAlgebra_eq_iff] at IMPORTANT
  simp
  intro n
  left ; exact IMPORTANT n




  --convert (@qExpansion_congr k z (eisensteinSeries_MF hk a) (eisensteinSeries_MF hk a)).mpr


--theorem qexpansion_unique {f : ModularForm Œì(1) k} :
--set_option linter.unusedTactic false
lemma Sumequivoverq {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  ‚àë' n : ‚Ñï, @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n = ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  unfold eisensteincoeff
  rw [‚Üê obvsthing4]
  rw [tsum_eq_zero_add']
  ¬∑ simp only [‚ÜìreduceIte, neg_mul, pow_zero, smul_eq_mul, mul_one, Nat.add_eq_zero, one_ne_zero,
    and_false, Int.reduceNeg, zpow_neg, zpow_one, Set.coe_setOf, Set.mem_setOf_eq, add_right_inj,
    Nat.cast_mul, Nat.cast_ofNat]
    symm
    rw [‚Üê smul_eq_mul]
    symm
    simp_rw [‚Üê smul_eq_mul ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) _]
    rw [‚Üê tsum_const_smul'' ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π )]
    have : ‚àë' (¬´i¬ª : ‚Ñï+), ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) ‚Ä¢ ‚àë' (m : { x // x ‚à£ ¬´i¬ª }), ‚Üë‚Üë‚Üëm ^ (k - 1) * ùï¢ 1 ‚Üëz ^ (¬´i¬ª : ‚Ñï)
    = ‚àë' (¬´i¬ª : ‚Ñï), ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) ‚Ä¢ ‚àë' (m : { x // x ‚à£ ¬´i¬ª +1 }), ‚Üë‚Üë‚Üëm ^ (k - 1) * ùï¢ 1 ‚Üëz ^ ‚Üë(¬´i¬ª + 1) := by
      sorry
    rw [this]
    congr
    ext n
    rw [smul_mul_assoc]
    simp_all only [Nat.cast_mul, Nat.cast_ofNat, smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero, pow_eq_zero_iff',
      OfNat.ofNat_ne_zero, ofReal_eq_zero, false_or, I_ne_zero, or_false, ne_eq, _root_.inv_eq_zero, Nat.cast_eq_zero]
    left
    rw [mul_comm, ‚Üê smul_eq_mul (ùï¢ 1 ‚Üëz ^ (n + 1))]
    symm
    rw [‚Üê tsum_const_smul'' (ùï¢ 1 ‚Üëz ^ (n + 1))]
    simp_rw [mul_comm _ (ùï¢ 1 ‚Üëz ^ (n + 1))]
    rfl
  ¬∑ unfold Summable
    sorry
  ¬∑ apply keven

lemma obvsthing5 {z :‚Ñç }{k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m):
(qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ 0 = - (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k) := by
  have : @eisensteincoeff k 0 = (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)) := rfl
  rw [‚Üê this]
  symm

  have h‚ÇÅ : (‚àë' n : ‚Ñï, @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n) - @eisensteincoeff k 0  =
  ‚àë' n : ‚Ñï+, @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ (n : ‚Ñï) := by
    sorry
  have h‚ÇÇ : (‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n) - (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ 0
   =  (‚àë' n : ‚Ñï+, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ (n:‚Ñï)) := by
    sorry

  calc
    eisensteincoeff 0 = (‚àë' n : ‚Ñï, @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n) - (‚àë' n : ‚Ñï, @eisensteincoeff k (n + 1) ‚Ä¢ ùï¢ 1 z ^ (n + 1)) := by
      rw [tsum_eq_zero_add']
    _ = (‚àë' (n : ‚Ñï), (coeff ‚ÑÇ n) (qExpansion 1 (eisensteinSeries_MF hk a)) ‚Ä¢ ùï¢ 1 ‚Üëz ^ n) - ‚àë' (n : ‚Ñï), (coeff ‚ÑÇ (n + 1)) (qExpansion 1 (eisensteinSeries_MF hk a)) ‚Ä¢ ùï¢ 1 ‚Üëz ^ (n + 1) := by
      rw [Sumequivoverq]


  lemma obvsthing5' {z :‚Ñç }{k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m):
(qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ 0 = - (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k) := by
  have : @eisensteincoeff k 0 = (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)) := rfl
  rw [‚Üê this]
  subst keven
  simp_all only [neg_mul, PNat.val_ofNat, coeff_zero_eq_constantCoeff]
  unfold qExpansion eisensteinSeries_MF eisensteinSeries_SIF eisensteinSeries
  simp_all only [PNat.val_ofNat, Nat.cast_mul, Nat.cast_ofNat, SlashInvariantForm.coe_mk, constantCoeff_mk,
    Nat.factorial_zero, Nat.cast_one, inv_one, iteratedDeriv_zero, one_mul]
  unfold eisSummand

  sorry

-- ## Stuff from before

lemma eisensteinSeries_not_zero_at_infty1 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)
: ¬¨  ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a).toFun ‚à£[(k : ‚Ñ§)] A) := by
  push_neg
  use ‚ü®!![1,0;0,1] , by norm_num [Matrix.det_fin_two_of]‚ü©
  intro h
  rw [(eisensteinSeries_MF hk a ).slash_action_eq' ‚ü®!![1,0;0,1] , by norm_num [Matrix.det_fin_two_of]‚ü©] at h
  rw [isZeroAtImInfty_iff] at h
  rw [eisensteinSeries_MF_is hk a] at h
  rw [Zeta_function_eq] at h
  rw [i_pow_k_of_even' keven] at h
  have h : ‚àÉ A, ‚àÄ (z : ‚Ñç),A ‚â§ z.im ‚Üí ‚Äñ(fun z : ‚Ñç ‚Ü¶  - (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)
  + (2 * œÄ * i) ^ k * (k - 1).factorial ^ (-(1 : ‚Ñ§)) *
   ‚àë' (d : ‚Ñï+) (m : {s | s ‚à£ d}), ((m : ‚Ñï+) : ‚ÑÇ) ^ (k - 1) * cexp (2 * ‚ÜëœÄ * i * d * z)) z‚Äñ ‚â§ (‚àë' (x : ‚Ñï+), (x : ‚Ñù) ^ (-(k : ‚Ñ§)) : ‚Ñù) := by
    convert h (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k) : ‚Ñù) _ ; convert tsum_nonneg; sorry
  obtain ‚ü®N, h‚ü© := h
  --simp_rw [isZeroAtImInfty_iff]--,eisenstein_sif_is] at h

  --simp_rw [(eisensteinSeries_sif a k).slash_action_eq'] at h

  sorry


lemma eisensteinSeries_nin_CuspForm_Subspace {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  (eisensteinSeries_MF hk a) ‚àâ CuspForm_Subspace Œì(1) k := by
    intro h
    have h‚ÇÅ : ‚àÉ f : CuspForm Œì(1) k, eisensteinSeries_MF hk a = (isom Œì(1) k f : ModularForm Œì(1) k) := by
      have h‚ÇÅ‚ÇÅ: Surjective (isom Œì(1) k ) := by apply LinearEquiv.surjective
      unfold Surjective at h‚ÇÅ‚ÇÅ
      convert h‚ÇÅ‚ÇÅ (‚ü®eisensteinSeries_MF hk a, h‚ü©)
      constructor
      ¬∑ intro h‚ÇÅ‚ÇÇ
        simp_rw [h‚ÇÅ‚ÇÇ]
      ¬∑ intro h‚ÇÅ‚ÇÇ
        simp_rw [h‚ÇÅ‚ÇÇ]
    obtain ‚ü®f, fiseis‚ü© := h‚ÇÅ
    have h‚ÇÇ : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a) ‚à£[(k : ‚Ñ§)] A) := by
      intro A
      rw [fiseis]
      have h‚ÇÉ : ‚àÄ B : SL(2,‚Ñ§), IsZeroAtImInfty
        (‚áëf.toSlashInvariantForm ‚à£[(k : ‚Ñ§)] B) := by apply f.zero_at_infty'
      simp_rw [isZeroAtImInfty_iff] at *
      intro Œµ Œµge0
      rcases h‚ÇÉ A Œµ Œµge0 with ‚ü®Œ¥, h‚ÇÑ‚ü©
      use Œ¥
      intro z Œ¥lezIm
      have h‚ÇÑ : ‚Äñ(‚áëf.toSlashInvariantForm ‚à£[(k : ‚Ñ§)] A) z‚Äñ ‚â§ Œµ := by apply h‚ÇÑ z Œ¥lezIm
      convert h‚ÇÑ
    have h‚ÇÉ : ¬¨ ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a) ‚à£[(k : ‚Ñ§)] A) := by apply eisensteinSeries_not_zero_at_infty1 ; apply keven
    contradiction

lemma subspacelemma (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) (x : Subspace ‚ÑÇ  (ModularForm Œì(1) k)) :
x ‚â§ (Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) ‚Üî
‚àÄ f ‚àà x, ‚àÉ c : ‚ÑÇ, f = c ‚Ä¢ (eisensteinSeries_MF hk a) := sorry

lemma subspacelemma2 (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) (x : Subspace ‚ÑÇ  (ModularForm Œì(1) k)) :
x ‚â§ CuspForm_Subspace Œì(1) k ‚Üî
‚àÄ f ‚àà x, ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty (f ‚à£[k] A) := sorry

/-
noncomputable instance Eisensteinseries (c : ‚ÑÇ) (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a} where
  val := c ‚Ä¢ (eisensteinSeries_MF hk a)
  property := sorry

lemma equiv (c : ‚ÑÇ) (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)):
c ‚Ä¢ (eisensteinSeries_MF hk a) = Eisensteinseries c hk a := sorry
-/

lemma EisensteinSeries_in_EisensteinSubspace (c : ‚ÑÇ) (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
c ‚Ä¢ (eisensteinSeries_MF hk a) ‚àà Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a} := by sorry

lemma eisensteinSubspace_vanishing_is_zero (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))
(f : ModularForm Œì(1) k) (finEis : f ‚àà  Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a})
(fvanishes : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((f : ModularForm Œì(1) k) ‚à£[k] A)) : f = 0 := sorry

theorem eisensteinSeries_comp_CuspForm (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
IsCompl (Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) (CuspForm_Subspace Œì(1) k) := by
  apply isCompl_iff.mpr
  constructor
  ¬∑ unfold Disjoint
    intro x h‚ÇÅ h‚ÇÇ
    rw [subspacelemma hk a] at h‚ÇÅ
    rw [subspacelemma2 hk a] at h‚ÇÇ
    intro f h‚ÇÑ
    simp
    have h‚ÇÖ : ‚àÉ c : ‚ÑÇ, f = c ‚Ä¢ (eisensteinSeries_MF hk a) := by apply h‚ÇÅ f; apply h‚ÇÑ
    rcases h‚ÇÖ with ‚ü®c, h‚ÇÖ‚ü©
    have h‚ÇÜ : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty (f ‚à£[k] A) := by apply h‚ÇÇ f; apply h‚ÇÑ
    rw [h‚ÇÖ] at h‚ÇÜ
    rw [h‚ÇÖ]
    apply eisensteinSubspace_vanishing_is_zero hk a
    apply EisensteinSeries_in_EisensteinSubspace c hk a
    apply h‚ÇÜ
  ¬∑ unfold Codisjoint
    intro x h‚ÇÅ h‚ÇÇ
    sorry

instance id‚ÑÇ : ‚ÑÇ ‚âÉ* ‚ÑÇ where
  toFun := fun z ‚Ü¶ z
  invFun := fun z ‚Ü¶ z
  left_inv := by tauto
  right_inv := by tauto
  map_mul' := by tauto

lemma idinj : Bijective id‚ÑÇ := by apply id‚ÑÇ.bijective
#check MulEquiv.refl

--¬´ ;) ¬ª
lemma rank_ModulaForm_equiv_prod (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
Module.rank ‚ÑÇ ((Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) √ó (CuspForm_Subspace Œì((1 : ‚Ñï+)) k))
= Module.rank ‚ÑÇ (ModularForm Œì(‚Üë1) k) := by
  apply rank_eq_of_equiv_equiv id‚ÑÇ (LinearEquiv.toAddEquiv (Submodule.prodEquivOfIsCompl (Submodule.span ‚ÑÇ {(eisensteinSeries_MF hk a : (ModularForm Œì((1 : ‚Ñï+)) k))}) (CuspForm_Subspace Œì((1 : ‚Ñï+)) k)  (eisensteinSeries_comp_CuspForm hk a) ) )
  apply idinj
  intro r m
  simp [id‚ÑÇ]

lemma rank_eisensteinSubspace_one (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
 Module.rank ‚ÑÇ ‚Ü•(Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) = 1 := by
  rw [rank_submodule_eq_one_iff]
  use eisensteinSeries_MF hk a
  constructor
  ¬∑ unfold Submodule.span
    simp
  constructor
  ¬∑ apply Eisenstein_series_not_zero
  ¬∑ tauto

theorem dimen (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
Module.rank ‚ÑÇ (ModularForm Œì(1) k) = Module.rank ‚ÑÇ (CuspForm_Subspace Œì(1) k) + 1 := by
  rw [‚Üê rank_ModulaForm_equiv_prod hk a, rank_prod',add_comm, rank_eisensteinSubspace_one]
  rfl


-
