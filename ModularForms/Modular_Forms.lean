import Mathlib.NumberTheory.ModularForms.Basic
import Mathlib.NumberTheory.ModularForms.CongruenceSubgroups
import Mathlib.NumberTheory.ModularForms.Identities
import Mathlib.NumberTheory.ModularForms.LevelOne
import Mathlib.NumberTheory.ModularForms.SlashActions
import Mathlib.NumberTheory.ModularForms.EisensteinSeries.Basic
import Mathlib.NumberTheory.ModularForms.QExpansion
import Mathlib.Algebra.DirectSum.Algebra
import Mathlib.NumberTheory.Bernoulli

open EisensteinSeries CongruenceSubgroup
open ModularForm Complex Filter UpperHalfPlane Function
open ModularFormClass
open Complex Topology Manifold
open Classical


open scoped Real MatrixGroups CongruenceSubgroup

variable {k : ‚Ñ§} {F : Type*} [FunLike F ‚Ñç ‚ÑÇ] {Œì : Subgroup SL(2, ‚Ñ§)} (n : ‚Ñï) (f : F)
variable{N : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N)
variable {z : ‚Ñç}

local notation "I‚àû" => comap Complex.im atTop
local notation "ùï¢" => Periodic.qParam

notation "i" => Complex.I

instance fintoprod : (Fin 2 ‚Üí ‚Ñ§) ‚âÉ ‚Ñ§ √ó ‚Ñ§ where
  toFun := fun v => (v 0, v 1)
  invFun := fun v => fun n => if n = 0 then v.1 else v.2
  left_inv := by
    intro v ;
    simp_all only [Fin.isValue] ;
    ext b ;
    split
    next h =>
      subst h
      simp_all only [Fin.isValue]
    next h =>
      have : b = 1 := by sorry
      rw [this]
  right_inv := by
    intro v
    simp_all only [Fin.isValue, ‚ÜìreduceIte, one_ne_zero, Prod.mk.eta]

instance gammaset {k : ‚Ñï} (a : Fin 2 ‚Üí ZMod 1) : gammaSet 1 a = {fintoprod.invFun (x : ‚Ñ§ √ó ‚Ñ§) | x ‚â† 0} where
  toFun := fun v => (v (0 : Fin 2), v (1 : Fin 2 ))
  invFun := fun v => fun x => if x = 0 then v 0 else v 1
  left_inv := sorry
  right_inv := sorry

lemma eisensteinSeries_expand {k : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
eisensteinSeries a k  = fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï, ((x : ‚ÑÇ) + 1) ^(-(k:‚Ñ§)) + ‚àë' y : ‚Ñï, ‚àë' x : ‚Ñ§, ((y + 1)* (z : ‚ÑÇ) + x) ^ (-(k:‚Ñ§)):= by
  ext z
  unfold eisensteinSeries eisSummand
  simp_all only [PNat.val_ofNat, Fin.isValue, zpow_neg, zpow_natCast]
  unfold tsum
  --apply gammaset
  sorry

theorem cotagent_Formula_HasSum: HasSum (fun (n : ‚Ñï) => 1 / ((z : ‚ÑÇ) - (n + 1)) + 1 / ((z : ‚ÑÇ) + (n + 1))) (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ)) := by
  sorry

theorem cotagent_formula : ‚àë' (n : ‚Ñï), (1 / ((z : ‚ÑÇ) - (n + 1)) + 1 / ((z : ‚ÑÇ) + (n + 1))) = (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ)) := by
  convert HasSum.tsum_eq cotagent_Formula_HasSum

lemma bernoulli_cotagent_Formula {k : ‚Ñï } : HasSum (fun n : ‚Ñï => (2 * œÄ * i) ^ (2 * n) * (bernoulli' (2 * n)) / ((2 *n).factorial * z ^ (2 * n))) (œÄ * z * cos (œÄ * z)/ sin (œÄ * z)):= by
  sorry

lemma cotagent_as_exp : (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ)) = œÄ * i * (cexp (œÄ * i * z) + cexp (- œÄ * i * z)) / (cexp (œÄ * i * z) - cexp (-œÄ * i * z)) := by sorry

lemma cotagent_as_exp1 :  œÄ * i * (cexp (œÄ * i * z) + cexp (- œÄ * i * z)) / (cexp (œÄ * i * z) - cexp (-œÄ * i * z)) =
- œÄ * i - 2 * œÄ * i * cexp (2 * œÄ * i * z) /(1 -  cexp (2 * œÄ * i * z) ) := by sorry

lemma cotagent_as_exp2 : - œÄ * i - 2 * œÄ * i * cexp (2 * œÄ * i * z) /(1 -  cexp (2 * œÄ * i * z) ) =
- œÄ * i - 2 * œÄ *i * ‚àë'(d : ‚Ñï), cexp (2 * œÄ * i * (d + 1) *z) := by sorry

lemma cotagent_as_exp3 : (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ))  = - œÄ * i - 2 * œÄ *i * ‚àë'(d : ‚Ñï), cexp (2 * œÄ * i * (d + 1) *z) := by
  calc
    (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ)) = œÄ * i * (cexp (œÄ * i * z) + cexp (- œÄ * i * z)) / (cexp (œÄ * i * z) - cexp (-œÄ * i * z)) := by apply cotagent_as_exp
    _  = - œÄ * i - 2 * œÄ * i * cexp (2 * œÄ * i * z) /(1 -  cexp (2 * œÄ * i * z) ) := by apply cotagent_as_exp1
    _  = - œÄ * i - 2 * œÄ *i * ‚àë'(d : ‚Ñï), cexp (2 * œÄ * i * (d + 1) *z) := by apply cotagent_as_exp2


lemma rw_of_cotangent_base_case :
 ‚àë' x : ‚Ñ§, ((z:‚ÑÇ) + (x : ‚ÑÇ))^(- 2 : ‚Ñ§) =
 (2*œÄ*i)^ 2* ‚àë' d : ‚Ñï, (d + 1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
  have h : ‚àÄ z : ‚Ñç, ‚àë' (n : ‚Ñï), (1 / ((z : ‚ÑÇ) - (n + 1)) + 1 / ((z : ‚ÑÇ) + (n + 1))) = (œÄ * cos (œÄ * z)/ sin (œÄ * z) - 1 / (z : ‚ÑÇ)) := by intro œÑ ; convert cotagent_formula
  symm
  simp_rw [cotagent_as_exp3] at h
  have h‚ÇÅ : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun œÑ : ‚ÑÇ => -œÄ *i) 0 z := by sorry
  have h‚ÇÇ {d : ‚Ñ§} : ‚àÄ z : ‚ÑÇ,HasDerivAt (fun z => cexp (2 * ‚ÜëœÄ * i * (d + 1) * (ofComplex z : ‚ÑÇ))) (2 * ‚ÜëœÄ * i * (d + 1) * cexp (2 * ‚ÜëœÄ * i * (d + 1) * (ofComplex z : ‚ÑÇ))) z := by sorry
  have h‚ÇÉ {d : ‚Ñ§} : ‚àÄ z : ‚ÑÇ,HasDerivAt (fun z =>  2 * ‚ÜëœÄ * i * ‚àë' (d : ‚Ñï), cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * (ofComplex z))) ((2 * ‚ÜëœÄ * i) ^ 2 * ‚àë' (d : ‚Ñï), cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * (ofComplex z : ‚ÑÇ))) z := by sorry
  have h‚ÇÑ {d : ‚Ñ§} : ‚àÄ z : ‚ÑÇ,HasDerivAt (fun z => (1 / ((z : ‚ÑÇ)))) (1 / (z : ‚ÑÇ) ^ 2) z := by sorry
  have h‚ÇÖ : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun z  => ‚àë' (n : ‚Ñï), (1 / ((ofComplex z : ‚ÑÇ) - (‚Üën + 1)))) (‚àë' (n : ‚Ñï), (1 / ((ofComplex z : ‚ÑÇ) + (‚Üën + 1)) ^ 2)) z := by sorry
  have h‚ÇÜ : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun z =>  ‚àë' (n : ‚Ñï), (1 / ((ofComplex z : ‚ÑÇ) - (‚Üën + 1)) + 1 / ((ofComplex z : ‚ÑÇ) + (‚Üën + 1)))) (- ‚àë' (n : ‚Ñ§), (1 / ((ofComplex z : ‚ÑÇ) + (‚Üën))^2)) z := by sorry
  have h‚Çá : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun z => -‚ÜëœÄ * i - 2 * ‚ÜëœÄ * i * ‚àë' (d : ‚Ñï), cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * (ofComplex z : ‚ÑÇ ))) (- (2 * ‚ÜëœÄ * i) ^ 2 * ‚àë' (d : ‚Ñï), (d + 1) * cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * ‚Üëz)) z := by sorry
  have h‚Çà : deriv (fun z => ‚àë' (n : ‚Ñï), (1 / ((ofComplex z : ‚ÑÇ) - (‚Üën + 1)) + 1 / ((ofComplex z : ‚ÑÇ) + (‚Üën + 1)))) z =
  deriv (fun z => -‚ÜëœÄ * i - 2 * ‚ÜëœÄ * i * ‚àë' (d : ‚Ñï), cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * ‚Üë(ofComplex z : ‚ÑÇ))) z := by congr; ext œÑ; simp_rw [h (ofComplex œÑ)]
  have h‚Çâ : - ‚àë' (n : ‚Ñ§), (1 / ((z : ‚ÑÇ) + (‚Üën))^2) = - (2 * ‚ÜëœÄ * i) ^ 2 * ‚àë' (d : ‚Ñï), (d + 1) * cexp (2 * ‚ÜëœÄ * i * (‚Üëd + 1) * ‚Üëz) := by rw [deriv_eq h‚ÇÜ] at h‚Çà ; symm ; rw [deriv_eq h‚Çá] at h‚Çà ; simp only [ofComplex_apply] at h‚Çà ; rw [h‚Çà]
  rw [neg_mul,neg_inj] at h‚Çâ
  simp_all
  symm
  rw [‚Üê h‚Çâ]
  norm_cast

lemma cotagent_derivative_formula {k : ‚Ñï} (hk : 2 ‚â§ k) :  ‚àÄ z : ‚Ñç, ((k - 1).factorial) * ‚àë' x : ‚Ñ§, 1/((z:‚ÑÇ) + (x : ‚ÑÇ))^((k: ‚Ñ§)) =  (2*œÄ*i)^ k * ‚àë' d : ‚Ñï, (d + 1) ^ (k - 1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
  induction' k with l ih
  linarith
  intro œÑ
  have h‚ÇÉ : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun z => ((l - 1).factorial : ‚Ñ§) * ‚àë' (x : ‚Ñ§), 1/((ofComplex z : ‚ÑÇ) + x) ^ ((l : ‚Ñ§))) ( (l + 1 - 1).factorial * ‚àë' (n : ‚Ñ§), (1 / ((ofComplex z : ‚ÑÇ) + (‚Üën))^(l + 1))) z := by sorry
  have h‚ÇÑ : ‚àÄ z : ‚ÑÇ, HasDerivAt (fun z => (2 * œÄ * i) ^ (l : ‚Ñ§) * ‚àë' (d : ‚Ñï), ((d :‚Ñ§) + 1) ^ (l - 1) * cexp (2 * œÄ * i * ((d :‚Ñ§) + 1) * (ofComplex z : ‚ÑÇ))) ((2 * œÄ * i) ^ (l + 1: ‚Ñ§) * ‚àë' (d : ‚Ñï), ((d :‚Ñ§) + 1) ^ (l) * cexp (2 * œÄ * i * ((d :‚Ñ§) + 1) * (ofComplex z : ‚ÑÇ))) z := by sorry
  have deriv_ih : 2 ‚â§ l ‚Üí (deriv (fun z => ((l - 1).factorial : ‚Ñ§) * ‚àë' (x : ‚Ñ§), 1/((ofComplex z : ‚ÑÇ) + x) ^ ((l : ‚Ñ§)))) œÑ
   = deriv (fun z => (2 * œÄ * i) ^ (l : ‚Ñ§) * ‚àë' (d : ‚Ñï), ((d :‚Ñ§) + 1) ^ (l - 1) * cexp (2 * œÄ * i * ((d :‚Ñ§) + 1) * (ofComplex z : ‚ÑÇ))) œÑ := by
    intro hyp
    congr
    ext œÑ
    convert ih hyp (ofComplex œÑ)
  rw [deriv_eq h‚ÇÉ, deriv_eq h‚ÇÑ] at deriv_ih
  have deriv_ih : (fun x ‚Ü¶  ‚Üë(l + 1 - 1).factorial * ‚àë' (n : ‚Ñ§), 1 / (((ofComplex x): ‚ÑÇ) + ‚Üën) ^ (l + 1)) œÑ =
    (fun x ‚Ü¶ ( (2 * œÄ * i) ^ (l +1: ‚Ñ§) * ‚àë' (d : ‚Ñï), ((d :‚Ñ§) + 1) ^ (l ) * cexp (2 * œÄ * i * ((d :‚Ñ§) + 1) * (ofComplex x : ‚ÑÇ)))) œÑ := by apply deriv_ih ; sorry --have 2 ‚â§ l + 1
  simp only [add_tsub_cancel_right, ofComplex_apply, neg_mul, neg_inj] at deriv_ih
  simp only [add_tsub_cancel_right, Nat.cast_add, Nat.cast_one, Int.reduceNeg]
  norm_cast
  rw [deriv_ih]
  norm_cast

lemma rw_of_cotangent {k : ‚Ñï } (hk : 2 ‚â§ k) :
 ‚àë' x : ‚Ñ§, ((z:‚ÑÇ) + (x : ‚ÑÇ))^(-(k : ‚Ñ§)) =
 (2*œÄ*i)^k* (Nat.factorial (k - 1) )^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï, (d + 1) ^ (k - 1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
    have h‚ÇÅ : ‚àÄ z : ‚Ñç, ((k - 1).factorial) * ‚àë' x : ‚Ñ§, 1/((z:‚ÑÇ) + (x : ‚ÑÇ))^((k: ‚Ñ§)) =
    (2*œÄ*i)^ k * ‚àë' d : ‚Ñï, (d + 1) ^ (k - 1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by apply cotagent_derivative_formula hk
    have h‚ÇÅ : ((k - 1).factorial) * ‚àë' x : ‚Ñ§, 1/((z:‚ÑÇ) + (x : ‚ÑÇ))^((k: ‚Ñ§)) =
    (2*œÄ*i)^ k * ‚àë' d : ‚Ñï, (d + 1) ^ (k - 1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
      apply h‚ÇÅ z
    rw [mul_comm] at h‚ÇÅ
    symm at h‚ÇÅ
    rw [‚Üê @mul_inv_eq_iff_eq_mul‚ÇÄ,mul_comm, ‚Üê mul_assoc, @mul_comm ‚ÑÇ _ (((k - 1).factorial)‚Åª¬π : ‚ÑÇ)] at h‚ÇÅ
    symm at h‚ÇÅ
    simp_all only [zpow_natCast, one_div, zpow_neg, zpow_one]
    intro fakenews
    apply Nat.factorial_ne_zero (k -1)
    norm_cast at fakenews


theorem eisensteinSeries_eq_qExpansion {k : ‚Ñï } (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
eisensteinSeries a k =  fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï, ((x : ‚ÑÇ) + 1) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï,
‚àë' m : {s : ‚Ñï | (s + 1) ‚à£ (d + 1)}, m^(k-1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
  rw [eisensteinSeries_expand hk a]
  ext (z: ‚Ñç)
  have {y : ‚Ñï}: ‚àë' x : ‚Ñ§, ((y + 1)* (z:‚ÑÇ) + (x : ‚ÑÇ))^(-(k : ‚Ñ§)) = (2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï, (d + 1) ^ (k -1 ) * Complex.exp (2*œÄ*i*(d + 1)*(y + 1)*(z:‚ÑÇ)) := by
    have : ‚àÉ s : ‚Ñç, (s : ‚ÑÇ) = (y + 1) * z := sorry
    rcases this with ‚ü®s, h‚ü©
    simp_rw [mul_assoc (2 * œÄ * i * _)]
    rw [‚Üê h, rw_of_cotangent (by linarith)]
  simp only [this]
  have : ‚àë' (y : ‚Ñï), ‚àë' (d : ‚Ñï),(d + 1) ^(k -1)  * cexp (2*œÄ*i*(d + 1)*(y + 1)*z) = ‚àë' (d : ‚Ñï) (m : {s : ‚Ñï | (s + 1) ‚à£ d + 1}), m^(k-1) * cexp (2*œÄ*i*(d + 1)*z) := sorry
  congr
  rw [tsum_mul_left]
  rw [this]


lemma isthisuseful {d : ‚Ñï+} : (fun z ‚Ü¶ Complex.exp (2*œÄ*i*d*z)) = Function.Periodic.qParam (1/d) := by
  unfold Function.Periodic.qParam
  simp
  ring_nf
lemma isthisuseful2 {d : ‚Ñï+} : Complex.exp (2*œÄ*i*d*z) = Function.Periodic.qParam (1/d) z := by unfold Function.Periodic.qParam; simp; ring_nf
lemma isthisuseful3 {d : ‚Ñï} : Complex.exp (2*œÄ*i*d*z) = Function.Periodic.qParam (1/d) z := by unfold Function.Periodic.qParam; simp; ring_nf


lemma nnamme {d : ‚Ñï+} : (fun z ‚Ü¶ Complex.exp (2*œÄ*i*d*z)) = Function.Periodic.cuspFunction (1/d : ‚Ñù) (fun z ‚Ü¶ z) := by
  rw [isthisuseful]
  ext x;
  unfold Periodic.cuspFunction Periodic.invQParam limUnder update
  simp
  refine eq_ite_iff.mpr ?_
  constructor
  constructor
  swap
  rw [lim]
  sorry
  sorry -- x = 0?


lemma eisenstein_sif_is {k : ‚Ñï} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+))  :
  eisensteinSeries_SIF a k = fun z:‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï, ((x : ‚ÑÇ) + 1) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï, ‚àë' m : {s : ‚Ñï | (s + 1) ‚à£ (d + 1)}, m^(k-1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by
  ext z
  rw [eisensteinSeries_SIF_apply, eisensteinSeries_eq_qExpansion hk]

lemma eisensteinSeries_MF_is {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
(eisensteinSeries_MF hk a).toFun = fun z : ‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï, ((x : ‚ÑÇ) + 1) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï, ‚àë' m : {s : ‚Ñï | (s + 1) ‚à£ (d + 1)}, m^(k-1) * Complex.exp (2*œÄ*i*(d + 1)*z) := by apply eisenstein_sif_is _ a ; norm_cast at hk

--THIS ONE IS BETTER
lemma eisensteinSeries_MF_is' {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
(eisensteinSeries_MF hk a) = fun z : ‚Ñç ‚Ü¶ 2 * ‚àë' x : ‚Ñï+, ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§)) +
(2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * ‚àë' d : ‚Ñï+, ‚àë' m : {s : ‚Ñï+ | s ‚à£ d}, m^(k-1) * Complex.exp (2*œÄ*i*d*z) := by sorry -- apply eisenstein_sif_is _ a ; norm_cast at hk

open DirectSum
open scoped DirectSum

#check CuspForm.zero_at_infty'

lemma bdd_at_infty_of_zero_at_infty (f : CuspForm Œì k) : ‚àÄ A : SL(2, ‚Ñ§), IsBoundedAtImInfty (f ‚à£[k] A) := by
  intro A
  have h‚ÇÅ : IsZeroAtImInfty (f ‚à£[k] A) := by
    apply CuspForm.zero_at_infty' f
  rw [UpperHalfPlane.isBoundedAtImInfty_iff]
  rw [UpperHalfPlane.isZeroAtImInfty_iff] at h‚ÇÅ
  use 1
  apply h‚ÇÅ _ _
  linarith

--they showed this already for ModularFormClass F Œì k with F œÄ type
instance coe_CuspForm (f : CuspForm Œì k) : ModularForm Œì k where
  toFun := f
  slash_action_eq' := by apply SlashInvariantForm.slash_action_eq'
  holo' := by apply CuspForm.holo'
  bdd_at_infty' := by apply bdd_at_infty_of_zero_at_infty

def coe_Hom' : CuspForm Œì k  ‚Üí+ ModularForm Œì k where
  toFun := coe_CuspForm
  map_zero' := by rfl
  map_add' := by intro f g ; rfl

def coe_Hom : CuspForm Œì k ‚Üí[‚ÑÇ] ModularForm Œì k where
  toFun := coe_Hom'
  map_smul' := by intro c f ; rfl

instance CuspForm_Subspace (Œì : Subgroup SL(2, ‚Ñ§)) (k : ‚Ñ§): Submodule ‚ÑÇ (ModularForm Œì k) where
  carrier := Set.range coe_Hom
  add_mem' := by
    intro f g h h‚ÇÅ
    simp ; simp at h ; simp at h‚ÇÅ
    rcases h with ‚ü®f1, hf‚ü© ; rcases h‚ÇÅ with ‚ü®g1, hg‚ü©
    use (f1 + g1)
    rw [‚Üê hf,‚Üê hg]
    rfl
  zero_mem' := by simp ; use 0 ; rfl
  smul_mem' := by
    intro c f h
    simp ; simp at h
    rcases h with ‚ü®g, h‚ÇÅ‚ü©; use (c ‚Ä¢ g)
    simp ; rw [h‚ÇÅ]

lemma coee {f : CuspForm Œì k} :
coe_Hom f ‚àà CuspForm_Subspace Œì k := by tauto

#check Classical.choose
lemma coe_hom_inj {f g : CuspForm Œì k} : (coe_Hom f = coe_Hom g) ‚Üí f = g  := by intro h ; unfold coe_Hom coe_Hom' at *; sorry

lemma coe_hom_surj (f : ModularForm Œì k) (finCuspSub : f ‚àà (CuspForm_Subspace Œì k)) :
‚àÉ g : CuspForm Œì k, f = coe_Hom g := by
  have finCuspSub: f ‚àà Set.range coe_Hom := by tauto
  have : (CuspForm_Subspace Œì k).carrier ‚äÜ Set.range coe_Hom := by rfl
  rw [Set.subset_range_iff_exists_image_eq] at this
  obtain ‚ü®t, tis‚ü© := this
  have h‚ÇÅ: (CuspForm_Subspace Œì k).carrier = Set.range ‚áëcoe_Hom := rfl
  rw [h‚ÇÅ] at tis
  rw [‚Üê tis] at finCuspSub
  unfold Set.image at *
  have h‚ÇÇ : ‚àÉ a ‚àà t, coe_Hom a = f := by apply finCuspSub
  obtain ‚ü®a, aint‚ü© := h‚ÇÇ
  use a
  tauto

open Classical


instance isom (Œì : Subgroup SL(2, ‚Ñ§)) (k : ‚Ñ§) :
  (CuspForm Œì k) ‚âÉ‚Çó[‚ÑÇ] CuspForm_Subspace Œì k where
    toFun := fun f => ‚ü®coe_Hom f , coee‚ü©
    map_add' := by intro x y; tauto
    map_smul' := by intro c x ; tauto
    invFun := fun ‚ü®f,finCusp‚ü© => Exists.choose (coe_hom_surj f finCusp)
    left_inv := by
      intro x; simp;
      convert Classical.choose_eq _  ; constructor ;
      intro h‚ÇÅ ; apply coe_hom_inj ; symm ; apply h‚ÇÅ
      intro h‚ÇÅ ; rw [h‚ÇÅ]
    right_inv := by
      intro x ; simp
      obtain ‚ü®val, property‚ü© := x
      simp_all only [Subtype.mk.injEq]


      --convert Classical.choose_eq _
      --simp
      --rw [Classical.choose_eq val]
      convert Classical.choose_eq _ ; simp ;
      refine ModularForm.ext_iff.mpr ?_
      intro œÑ

      sorry

-- ## Back to Eisenstein series


noncomputable def pow1 (k : ‚Ñï)  := fun x : ‚Ñï ‚Ü¶ 2 * ((x : ‚ÑÇ)) ^(-(k : ‚Ñ§))
noncomputable def pow2 (k : ‚Ñï)  := fun x : ‚Ñï ‚Ü¶ (2*œÄ*i)^k* (Nat.factorial (k-1))^(-(1:‚Ñ§)) * (‚àë' m : {s : ‚Ñï+ | (s : ‚Ñï) ‚à£ x}, (m : ‚Ñï)^(k-1))-- * ùï¢ x‚Åª¬π z-- Complex.exp (2*œÄ*i*x*z)

lemma  zeta_HasSum_eq_bernoulli {k : ‚Ñï} :
HasSum (pow1 k)  (- (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k)) := by sorry

lemma eisenstein_q_expansion {k : ‚Ñï}  (hk : 3 ‚â§ (k:‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1:‚Ñï+)) :
  qExpansion 1 (eisensteinSeries_MF hk a)  = .mk (pow1 k) +.mk ( pow2 k) := by
  unfold pow1 pow2 qExpansion SlashInvariantFormClass.cuspFunction
  unfold iteratedDeriv
  simp_all only [Nat.cast_one, PNat.val_ofNat, zpow_neg, zpow_natCast, Int.reduceNeg, zpow_one, Set.coe_setOf,
    Set.mem_setOf_eq]
  sorry
  --rw [eisensteinSeries_MF_is hk a] --maybe add another version of the above for this coercion?
  --unfold Periodic.cuspFunction --iteratedDeriv iteratedFDeriv
  --simp
  --ext n
  --simp only [iteratedDeriv_eq_iterate, Periodic.eq_cuspFunction]
  --unfold Periodic.cuspFunction
  --simp_rw [isthisuseful2,isthisuseful3]
  --sorry

lemma Eisenstein_series_ne_zero  {k : ‚Ñ§} {N : ‚Ñï+} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N) :
 qExpansion N (eisensteinSeries_MF hk a) ‚â† 0 := by
  intro h
  rw [‚Üê PowerSeries.forall_coeff_eq_zero] at h
  have h‚ÇÅ : PowerSeries.coeff ‚ÑÇ 0 (qExpansion N (eisensteinSeries_MF hk a)) = 1 := by sorry --exact Eisenstein_0th_coeff_one N hk a
  rw [h 0] at h‚ÇÅ
  have : 0 = (1:‚ÑÇ) ‚Üí False := by simp
  apply this ; apply h‚ÇÅ

lemma Eisenstein_series_not_zero {k : ‚Ñ§} {N : ‚Ñï+} (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod N) :
  eisensteinSeries_MF hk a ‚â† 0 := by
  intro h
  have h‚ÇÅ : qExpansion N (eisensteinSeries_MF hk a) = 0 := by
    rw [h]
    ext j
    simp
    unfold qExpansion
    simp
    right
    unfold SlashInvariantFormClass.cuspFunction

    --rw [Periodic.cuspFunction_zero_of_zero_at_inf]
    sorry
  apply Eisenstein_series_ne_zero
  exact h‚ÇÅ


theorem qExpansion_unique {f g : ModularForm Œì k} : qExpansion 1 f = qExpansion 1 g ‚Üî f = g := by sorry



lemma Zeta_function_eq {k : ‚Ñï} : ‚àë' (x : ‚Ñï+), (x : ‚ÑÇ) ^ (-(k : ‚Ñ§)) = - (2 * œÄ * i) ^ k * (bernoulli' k) / (2 * Nat.factorial k) := by
  sorry
lemma i_pow_k_of_even {k m: ‚Ñï} (keven:  k = 2 * m) : i ^ k = (- 1) ^ m := sorry

lemma i_pow_k_of_even' {k m: ‚Ñï} (keven:  k = 2 * m) : (2 * œÄ * i) ^ k = (- 1) ^ m * (2 * œÄ ) ^ k := sorry

theorem eisensteinSeries_apply_zero {k: ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)):
    SlashInvariantFormClass.cuspFunction 0 (eisensteinSeries_MF hk a) 0 = - (2 * œÄ * i) ^ k * (bernoulli' k) / (Nat.factorial k) := by
    sorry

lemma eq_CuspFunction {f : ModularForm Œì(1) k} : f.toFun = fun œÑ : ‚Ñç ‚Ü¶ SlashInvariantFormClass.cuspFunction 1 f (ùï¢ 1 œÑ) := sorry
--#check fun i, p i \smul continuous_linear_map.pi_algebra

open PowerSeries
noncomputable instance FPowerSeries_of_PowerSeries : ‚ÑÇ‚ü¶X‚üß ‚Üí‚Çó[‚ÑÇ] FormalMultilinearSeries ‚ÑÇ ‚ÑÇ ‚ÑÇ where
  toFun œà := fun m ‚Ü¶ œà.coeff ‚ÑÇ m ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m _
  map_add' := by intro œà œÜ ; simp ; ext m h‚ÇÅ ; ring_nf ; simp ; ring_nf
  map_smul' := by
    intro c œà ; simp_all only [map_smul, smul_eq_mul, RingHom.id_apply] ;
    ext m h‚ÇÅ ;
    simp_all only [ContinuousMultilinearMap.smul_apply, ContinuousMultilinearMap.mkPiAlgebraFin_apply, smul_eq_mul,
      FormalMultilinearSeries.smul_apply]
    ring_nf

@[simp]
lemma coe_inj :  Injective FPowerSeries_of_PowerSeries := by
  intro œà œÜ h
  simp [FPowerSeries_of_PowerSeries] at h
  sorry


lemma modularForms_is_periodic {œÑ : ‚ÑÇ} {f : ModularForm Œì(1) k} : f (ofComplex (œÑ + 1)) = f (ofComplex œÑ) := by sorry

lemma modularForms_is_differentiable {f : ModularForm Œì(1) k} : ‚àÄ·∂† (z : ‚ÑÇ) in I‚àû, DifferentiableAt ‚ÑÇ (‚áëf ‚àò ‚ÜëofComplex) z := by
  sorry
lemma modularForms_is_BoundedAtFilter {f : ModularForm Œì(1) k} : I‚àû.BoundedAtFilter (‚áëf ‚àò ‚ÜëofComplex) := by sorry

--lemma eq_multilin : f = qExpansionFormalMultilinearSeries 1 f
lemma modularForm_TendsTo_Filter_at_zero {f : ModularForm Œì(1) k} (hyp : (coeff ‚ÑÇ 0) (qExpansion 1 f) = 0 ): Filter.Tendsto f (Filter.comap UpperHalfPlane.im Filter.atTop) (ùìù 0) := by
      convert @Function.Periodic.tendsto_at_I_inf 1 (‚áëf ‚àò ofComplex) _ _ _ _
      ¬∑ ext F
        constructor
        ¬∑ intro h
          simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
            using (h).comp tendsto_comap_im_ofComplex
        ¬∑ intro h‚ÇÅ s h‚ÇÇ
          obtain ‚ü®t, h‚ÇÉ‚ü© := h‚ÇÅ h‚ÇÇ
          use t
          simp_all only [Nat.cast_one, mem_atTop_sets, ge_iff_le, true_and]
          obtain ‚ü®left, right‚ü© := h‚ÇÉ
          obtain ‚ü®w, h_1‚ü© := left
          convert right
          simp_all only [coeff_zero_eq_constantCoeff, iff_true]
          intro r h‚ÇÉ

          simp_all only [Set.mem_preimage]
          refine Set.mem_preimage.mp ?_
          have thing: (r : ‚ÑÇ)  ‚àà (Complex.im ‚Åª¬π' t) := by apply h‚ÇÉ
          have thing1  : (r : ‚ÑÇ) ‚àà ‚áëf ‚àò ‚ÜëofComplex ‚Åª¬π' s := by apply right; convert thing
          convert thing1
          simp_all only [SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe, Set.mem_preimage, coe_im,
            comp_apply, ofComplex_apply]
      ¬∑ unfold qExpansion at hyp
        simp_all only [coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one, iteratedDeriv_zero, one_mul]
        unfold SlashInvariantFormClass.cuspFunction at hyp
        convert hyp
        simp_all only [Nat.cast_one]
        simp_all only [Nat.cast_one]
      ¬∑ simp
      ¬∑ simp_all only [coeff_zero_eq_constantCoeff, Nat.cast_one, Periodic, ofReal_one, comp_apply]
        intro x
        apply modularForms_is_periodic
      ¬∑ apply modularForms_is_differentiable
      ¬∑ apply modularForms_is_BoundedAtFilter

theorem zeroAtInfty_iff_CuspForm {f : ModularForm Œì(1) k} : (‚àÄ A : SL(2, ‚Ñ§), IsZeroAtImInfty (f.toFun ‚à£[(k : ‚Ñ§)] A)) ‚Üî (qExpansion 1 f).coeff ‚ÑÇ 0 = 0 := by
  constructor
  ¬∑ intro h
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul]
    unfold IsZeroAtImInfty ZeroAtFilter at h
    unfold SlashInvariantFormClass.cuspFunction
    apply Periodic.cuspFunction_zero_of_zero_at_inf
    simp
    simpa only [SlashAction.slash_one, toSlashInvariantForm_coe]
    using (h 1).comp tendsto_comap_im_ofComplex
  ¬∑ intro h
    have cloneh : (coeff ‚ÑÇ 0) (qExpansion 1 f) = 0 := h
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul] at h
    intro A
    rw [f.slash_action_eq' A]
    unfold SlashInvariantFormClass.cuspFunction at h
    rw [Function.Periodic.cuspFunction_zero_eq_limUnder_nhds_ne] at h
    unfold IsZeroAtImInfty
    simp_all only [Nat.cast_one, SlashInvariantForm.toFun_eq_coe, toSlashInvariantForm_coe]
    unfold ZeroAtFilter atImInfty
    convert modularForm_TendsTo_Filter_at_zero cloneh
    simp only [qExpansion, PowerSeries.coeff_mk, Nat.factorial_zero, Nat.cast_one, inv_one,
    iteratedDeriv_zero, one_mul] at cloneh
    rw [Gamma_one_top]
    simp only [Subgroup.mem_top]


--consider deleting this
lemma lemma1 {f g : ModularForm Œì(1) k} {h : qExpansion 1 f = qExpansion 1 g}:  qExpansionFormalMultilinearSeries 1 f = qExpansionFormalMultilinearSeries 1 g := by
      unfold qExpansionFormalMultilinearSeries
      rw [h]

lemma lemma2 {f g : ModularForm Œì(1) k} {h : qExpansion 1 f = qExpansion 1 g}: HasFPowerSeriesOnBall (SlashInvariantFormClass.cuspFunction 1 g) (qExpansionFormalMultilinearSeries 1 f) 0 1 := by
      rw [lemma1]
      apply hasFPowerSeries_cuspFunction 1 g
      apply h

theorem qExpansion_congr {f g : ModularForm Œì(1) k}: qExpansion 1 f = qExpansion 1 g  ‚Üî ‚àÄ n : ‚Ñï, (qExpansion 1 f).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n = (qExpansion 1 g).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  constructor
  ¬∑ intro h n
    simp only [smul_eq_mul, mul_eq_mul_right_iff, pow_eq_zero_iff', ne_eq]
    left
    rw [h]
  ¬∑ intro h
    ext n
    simp only [smul_eq_mul, mul_eq_mul_right_iff, pow_eq_zero_iff', ne_eq] at h
    have : ùï¢ 1 ‚Üëz ‚â† 0 := by
      intro h‚ÇÅ
      unfold Periodic.qParam at h‚ÇÅ
      simp_all only [ofReal_one, div_one, exp_ne_zero]
    have : (coeff ‚ÑÇ n) (qExpansion 1 f) = (coeff ‚ÑÇ n) (qExpansion 1 g) := by
      convert h n
      simp_all only [false_and, or_false, ne_eq]
    apply this






lemma obvsthing {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n) ((eisensteinSeries_MF hk a) z) := by
 convert hasSum_qExpansion 1 (eisensteinSeries_MF hk a) z
 norm_cast

lemma obvsthing' {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ q ^ n) (SlashInvariantFormClass.cuspFunction 1 (eisensteinSeries_MF hk a) q) := by
 sorry

lemma obvsthing4 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
(- (2 * œÄ * i) ^ k * (bernoulli' k) / Nat.factorial k
  + (2 * œÄ * i) ^ k * (k - 1).factorial ^ (-(1 : ‚Ñ§)) *
   ‚àë' (d : ‚Ñï+) (m : {s | s ‚à£ d}), ((m : ‚Ñï+) : ‚ÑÇ) ^ (k - 1) ‚Ä¢ ùï¢ 1 z ^ (d:‚Ñï) )=
    ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  sorry

noncomputable def eisensteincoeff {k : ‚Ñï} : ‚Ñï ‚Üí ‚ÑÇ :=
  fun n => if n = 0 then (- (2 * œÄ * i) ^ k * (bernoulli' k) / Nat.factorial k)
  else (2 * œÄ * i) ^ k * (k - 1).factorial ^ (-(1 : ‚Ñ§)) * ‚àë' (m : {s | s ‚à£ n }), (m : ‚ÑÇ) ^ (k - 1)

lemma eisensteinSeries_is_tsum_eisensteincoeff {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§))
 (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 eisensteinSeries_MF hk a z = (‚àë' (n : ‚Ñï), @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n) := by sorry

lemma eisensteinSeries_is_tsum_eisensteincoeff' {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§))
 (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 eisensteinSeries_MF hk a z = (‚àë' (n : ‚Ñï), @eisensteincoeff k n ‚Ä¢ q ^ n) := by sorry

lemma obvsthing7 {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (@eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n)) ((eisensteinSeries_MF hk a) z) := by
  rw [eisensteinSeries_is_tsum_eisensteincoeff]
  unfold HasSum Tendsto
  intro S h‚ÇÅ
  rename_i x
  subst x
  simp_all only [Nat.cast_mul, Nat.cast_ofNat, smul_eq_mul, mem_map, mem_atTop_sets, ge_iff_le, Finset.le_eq_subset,
    Set.mem_preimage]
  sorry
  assumption

lemma obvsthing8 {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(_ :  k = 2 * m)  :
 HasSum (fun n : ‚Ñï ‚Ü¶ (@eisensteincoeff k n ‚Ä¢ q ^ n)) (SlashInvariantFormClass.cuspFunction 1 (eisensteinSeries_MF hk a) q) := by
  sorry

open SlashInvariantFormClass

theorem coeffiecients_cancel {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) : ‚àÄ (n : ‚Ñï), (@eisensteincoeff k n) -
((qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n) = 0 := by

  sorry

noncomputable def eisensteinFormalMultilinearSeries {k : ‚Ñï} : FormalMultilinearSeries ‚ÑÇ ‚ÑÇ ‚ÑÇ :=
  fun m ‚Ü¶ @eisensteincoeff k m ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ m ‚ÑÇ

lemma hasFPowerSeries_eisen {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)  :
    HasFPowerSeriesOnBall (cuspFunction 1 (eisensteinSeries_MF hk a)) (@eisensteinFormalMultilinearSeries k) 0 1 := by
    have h‚ÇÅ : 1 ‚â§ ((@eisensteinFormalMultilinearSeries k)).radius := by sorry
    have h‚ÇÇ :  (0 : ENNReal) < 1 := by simp
    refine ‚ü®h‚ÇÅ, h‚ÇÇ ,  fun hy ‚Ü¶ ?_‚ü©
    rw [EMetric.mem_ball, edist_zero_right, enorm_eq_nnnorm, ENNReal.coe_lt_one_iff,
    ‚Üê NNReal.coe_lt_one, coe_nnnorm] at hy
    simp only [eisensteinFormalMultilinearSeries]
    simpa [eisensteinFormalMultilinearSeries] using (obvsthing8 hk a keven)

theorem EisensteinserieshasFPsum  {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 cuspFunction 1 (eisensteinSeries_MF hk a) q = (@eisensteinFormalMultilinearSeries k).sum q := by
  apply HasFPowerSeriesOnBall.unique (hasFPowerSeries_eisen hk a keven)
  convert FormalMultilinearSeries.hasFPowerSeriesOnBall (@eisensteinFormalMultilinearSeries k) _
  sorry --small things like radius arguments left
  sorry
  sorry


lemma eisensteinseries_FpowerseriesOnBall_difference_hassum {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m): HasFPowerSeriesOnBall ( cuspFunction 1 (eisensteinSeries_MF hk a) -  cuspFunction 1 (eisensteinSeries_MF hk a))
((@eisensteinFormalMultilinearSeries k) - (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a))) 0 1 := by
  have h‚ÇÅ  :  1 ‚â§ ((@eisensteinFormalMultilinearSeries k) -
  (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a))).radius := by sorry
  have h‚ÇÇ :  (0 : ENNReal) < 1 := by simp
  refine ‚ü®h‚ÇÅ, h‚ÇÇ ,  fun hy ‚Ü¶ ?_‚ü©
  apply HasSum.sub
  simpa [eisensteinFormalMultilinearSeries] using (obvsthing8 hk a keven)
  simpa [qExpansionFormalMultilinearSeries] using (obvsthing' hk a keven)

theorem eisensteinseries_FpowerseriesAt_difference_hassum {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 HasFPowerSeriesAt ( cuspFunction 1 (eisensteinSeries_MF hk a) -  cuspFunction 1 (eisensteinSeries_MF hk a))
((@eisensteinFormalMultilinearSeries k) - (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a))) 0 := by
  use 1
  apply eisensteinseries_FpowerseriesOnBall_difference_hassum hk a keven ; apply q

theorem eisensteinSeries_Fpowerseries_difference_eq_zero {k m : ‚Ñï} {q : ‚ÑÇ}  (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
 (@eisensteinFormalMultilinearSeries k) - (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a)) = 0:= by
  apply HasFPowerSeriesAt.eq_zero
  rw [‚Üê sub_self (cuspFunction 1 (eisensteinSeries_MF hk a))]
  apply eisensteinseries_FpowerseriesAt_difference_hassum hk a keven ; apply q

theorem TheFPSeriesagree {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  @eisensteinFormalMultilinearSeries k = qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) := by
  have h : (@eisensteinFormalMultilinearSeries k) - (qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a)) = 0 := by
    apply eisensteinSeries_Fpowerseries_difference_eq_zero hk a keven ; apply q
  rw [‚Üê sub_eq_zero]
  apply h

lemma TheFPSeriesagree2 {q : ‚ÑÇ }{k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)  :
 ‚àÄ (n : ‚Ñï), @eisensteinFormalMultilinearSeries k n =
 qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) n := by
  apply FormalMultilinearSeries.ext_iff.mp
  apply TheFPSeriesagree hk a keven ; apply q

theorem mkPiAlgebra_eq_iff (n : ‚Ñï)  {z‚ÇÅ z‚ÇÇ : ‚ÑÇ} :
    z‚ÇÅ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ  = z‚ÇÇ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ ‚Üî
      z‚ÇÅ = z‚ÇÇ := by
    apply Iff.intro
    ¬∑ intro a
      have h‚ÇÅ :  (z‚ÇÅ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ) - (z‚ÇÇ ‚Ä¢ ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ)= 0 := by
        simp_all only [sub_self]
      rw [‚Üê sub_smul z‚ÇÅ z‚ÇÇ (ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ)] at h‚ÇÅ
      rw [smul_eq_zero] at h‚ÇÅ
      have h‚ÇÇ : ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ ‚â† 0 := by
        intro h‚ÇÉ
        simp [ContinuousMultilinearMap.mkPiAlgebraFin] at h‚ÇÉ
        unfold MultilinearMap.mkPiAlgebraFin at h‚ÇÉ
        sorry --not sure how to show this isnt zero
      have h‚ÇÑ : ((z‚ÇÅ - z‚ÇÇ = 0) ‚à® (ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ = 0)) ‚àß (ContinuousMultilinearMap.mkPiAlgebraFin ‚ÑÇ n ‚ÑÇ ‚â† 0) := by
        exact ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
      simp_all only [or_false, ne_eq, not_false_eq_true, true_or, true_and]
      symm
      calc
        z‚ÇÇ = z‚ÇÇ + 0 := by simp
        _ = z‚ÇÇ + (z‚ÇÅ - z‚ÇÇ) := by rw [h‚ÇÅ]
        _ = z‚ÇÅ := by ring
    ¬∑ intro a
      subst a
      simp_all only

theorem coeff_of_q_expansions_agree  {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n = @eisensteincoeff k n := by
    have h‚ÇÅ : @eisensteinFormalMultilinearSeries k n =
 qExpansionFormalMultilinearSeries 1 (eisensteinSeries_MF hk a) n := by apply TheFPSeriesagree2 hk a keven ; apply q
    unfold eisensteinFormalMultilinearSeries qExpansionFormalMultilinearSeries  at h‚ÇÅ
    rw [mkPiAlgebra_eq_iff] at h‚ÇÅ
    rw [h‚ÇÅ]

lemma Sumequivoverq {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  ‚àë' n : ‚Ñï, @eisensteincoeff k n ‚Ä¢ ùï¢ 1 z ^ n = ‚àë' n : ‚Ñï, (qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ n ‚Ä¢ ùï¢ 1 z ^ n := by
  unfold eisensteincoeff
  rw [‚Üê obvsthing4]
  rw [tsum_eq_zero_add']
  ¬∑ simp only [‚ÜìreduceIte, neg_mul, pow_zero, smul_eq_mul, mul_one, Nat.add_eq_zero, one_ne_zero,
    and_false, Int.reduceNeg, zpow_neg, zpow_one, Set.coe_setOf, Set.mem_setOf_eq, add_right_inj,
    Nat.cast_mul, Nat.cast_ofNat]
    symm
    rw [‚Üê smul_eq_mul]
    symm
    simp_rw [‚Üê smul_eq_mul ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) _]
    rw [‚Üê tsum_const_smul'' ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π )]
    have : ‚àë' (¬´i¬ª : ‚Ñï+), ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) ‚Ä¢ ‚àë' (m : { x // x ‚à£ ¬´i¬ª }), ‚Üë‚Üë‚Üëm ^ (k - 1) * ùï¢ 1 ‚Üëz ^ (¬´i¬ª : ‚Ñï)
    = ‚àë' (¬´i¬ª : ‚Ñï), ((2 * ‚ÜëœÄ * i) ^ k * (‚Üë(k - 1).factorial)‚Åª¬π) ‚Ä¢ ‚àë' (m : { x // x ‚à£ ¬´i¬ª +1 }), ‚Üë‚Üë‚Üëm ^ (k - 1) * ùï¢ 1 ‚Üëz ^ ‚Üë(¬´i¬ª + 1) := by
      sorry
    rw [this]
    congr
    ext n
    rw [smul_mul_assoc]
    simp_all only [Nat.cast_mul, Nat.cast_ofNat, smul_eq_mul, mul_eq_mul_left_iff, mul_eq_zero, pow_eq_zero_iff',
      OfNat.ofNat_ne_zero, ofReal_eq_zero, false_or, I_ne_zero, or_false, ne_eq, _root_.inv_eq_zero, Nat.cast_eq_zero]
    left
    rw [mul_comm, ‚Üê smul_eq_mul (ùï¢ 1 ‚Üëz ^ (n + 1))]
    symm
    rw [‚Üê tsum_const_smul'' (ùï¢ 1 ‚Üëz ^ (n + 1))]
    simp_rw [mul_comm _ (ùï¢ 1 ‚Üëz ^ (n + 1))]
    rfl
  ¬∑ unfold Summable
    sorry
  ¬∑ apply keven

  lemma obvsthing5' {z :‚Ñç }{k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m):
(qExpansion 1 (eisensteinSeries_MF hk a)).coeff ‚ÑÇ 0 = - (2 * œÄ * i) ^ k * (bernoulli' k) / Nat.factorial k:= by
  have : @eisensteincoeff k 0 = (- (2 * œÄ * i) ^ k * (bernoulli' k) / Nat.factorial k) := rfl
  rw [‚Üê this]
  subst keven
  simp_all only [neg_mul, PNat.val_ofNat, coeff_zero_eq_constantCoeff]
  unfold qExpansion eisensteinSeries_MF eisensteinSeries_SIF eisensteinSeries
  simp_all only [PNat.val_ofNat, Nat.cast_mul, Nat.cast_ofNat, SlashInvariantForm.coe_mk, constantCoeff_mk,
    Nat.factorial_zero, Nat.cast_one, inv_one, iteratedDeriv_zero, one_mul]
  unfold eisSummand


  sorry

-- ## Stuff from before

lemma bernoulli_even_ne_zero (k : ‚Ñï) {m : ‚Ñï } (keven : k = 2 * m) : bernoulli' k ‚â† 0 := by sorry

theorem Eisenstein_coeff_not_zero {k m : ‚Ñï} (keven :  k = 2 * m) : @eisensteincoeff k 0 ‚â† 0 := by
  unfold eisensteincoeff
  intro h
  simp_all only [Nat.cast_mul, Nat.cast_ofNat, neg_mul, zpow_neg, zpow_one, Set.coe_setOf,
    Set.mem_setOf_eq, ite_true, div_eq_zero_iff, neg_eq_zero, mul_eq_zero, pow_eq_zero_iff',
    OfNat.ofNat_ne_zero, ofReal_eq_zero, false_or, I_ne_zero, or_false, ne_eq, Rat.cast_eq_zero,
    Nat.cast_eq_zero]
  repeat rw [‚Üê keven] at  h
  have h‚ÇÅ : bernoulli' k ‚â† 0 := by apply @bernoulli_even_ne_zero k m keven
  have h‚ÇÇ : k.factorial ‚â† 0 := by apply Nat.factorial_ne_zero
  simp_all only [or_false]
  have h‚ÇÉ : œÄ ‚â† 0 := by apply Real.pi_ne_zero
  have h‚ÇÉ : œÄ = 0 := by apply h.1
  contradiction

lemma eisensteinSeries_not_zero_at_infty1 {q : ‚ÑÇ}{k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m)
: ¬¨  ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a).toFun ‚à£[(k : ‚Ñ§)] A) := by
  rw [zeroAtInfty_iff_CuspForm]
  push_neg
  rw [coeff_of_q_expansions_agree 0 hk a keven]
  apply Eisenstein_coeff_not_zero keven
  repeat apply q


lemma eisensteinSeries_nin_CuspForm_Subspace {q : ‚ÑÇ} {k m : ‚Ñï} (hk : 3 ‚â§ (k : ‚Ñ§)) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))(keven :  k = 2 * m) :
  (eisensteinSeries_MF hk a) ‚àâ CuspForm_Subspace Œì(1) k := by
    intro h
    have h‚ÇÅ : ‚àÉ f : CuspForm Œì(1) k, eisensteinSeries_MF hk a = (isom Œì(1) k f : ModularForm Œì(1) k) := by
      have h‚ÇÅ‚ÇÅ: Surjective (isom Œì(1) k ) := by apply LinearEquiv.surjective
      unfold Surjective at h‚ÇÅ‚ÇÅ
      convert h‚ÇÅ‚ÇÅ (‚ü®eisensteinSeries_MF hk a, h‚ü©)
      constructor
      ¬∑ intro h‚ÇÅ‚ÇÇ
        simp_rw [h‚ÇÅ‚ÇÇ]
      ¬∑ intro h‚ÇÅ‚ÇÇ
        simp_rw [h‚ÇÅ‚ÇÇ]
    obtain ‚ü®f, fiseis‚ü© := h‚ÇÅ
    have h‚ÇÇ : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a) ‚à£[(k : ‚Ñ§)] A) := by
      intro A
      rw [fiseis]
      have h‚ÇÉ : ‚àÄ B : SL(2,‚Ñ§), IsZeroAtImInfty
        (‚áëf.toSlashInvariantForm ‚à£[(k : ‚Ñ§)] B) := by apply f.zero_at_infty'
      simp_rw [isZeroAtImInfty_iff] at *
      intro Œµ Œµge0
      rcases h‚ÇÉ A Œµ Œµge0 with ‚ü®Œ¥, h‚ÇÑ‚ü©
      use Œ¥
      intro z Œ¥lezIm
      have h‚ÇÑ : ‚Äñ(‚áëf.toSlashInvariantForm ‚à£[(k : ‚Ñ§)] A) z‚Äñ ‚â§ Œµ := by apply h‚ÇÑ z Œ¥lezIm
      convert h‚ÇÑ
    have h‚ÇÉ : ¬¨ ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((eisensteinSeries_MF hk a) ‚à£[(k : ‚Ñ§)] A) := by apply eisensteinSeries_not_zero_at_infty1 hk a keven ; apply q
    contradiction

lemma subspacelemma (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) (x : Subspace ‚ÑÇ  (ModularForm Œì(1) k)) :
x ‚â§ (Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) ‚Üî
‚àÄ f ‚àà x, ‚àÉ c : ‚ÑÇ, f = c ‚Ä¢ (eisensteinSeries_MF hk a) := sorry

lemma subspacelemma2 (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) (x : Subspace ‚ÑÇ  (ModularForm Œì(1) k)) :
x ‚â§ CuspForm_Subspace Œì(1) k ‚Üî
‚àÄ f ‚àà x, ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty (f ‚à£[k] A) := sorry


lemma EisensteinSeries_in_EisensteinSubspace (c : ‚ÑÇ) (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
c ‚Ä¢ (eisensteinSeries_MF hk a) ‚àà Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a} := by sorry

lemma eisensteinSubspace_vanishing_is_zero (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+))
(f : ModularForm Œì(1) k) (finEis : f ‚àà  Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a})
(fvanishes : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty ((f : ModularForm Œì(1) k) ‚à£[k] A)) : f = 0 := sorry

theorem eisensteinSeries_comp_CuspForm (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
IsCompl (Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) (CuspForm_Subspace Œì(1) k) := by
  apply isCompl_iff.mpr
  constructor
  ¬∑ unfold Disjoint
    intro x h‚ÇÅ h‚ÇÇ
    rw [subspacelemma hk a] at h‚ÇÅ
    rw [subspacelemma2 hk a] at h‚ÇÇ
    intro f h‚ÇÑ
    simp
    have h‚ÇÖ : ‚àÉ c : ‚ÑÇ, f = c ‚Ä¢ (eisensteinSeries_MF hk a) := by apply h‚ÇÅ f; apply h‚ÇÑ
    rcases h‚ÇÖ with ‚ü®c, h‚ÇÖ‚ü©
    have h‚ÇÜ : ‚àÄ (A : SL(2, ‚Ñ§)), IsZeroAtImInfty (f ‚à£[k] A) := by apply h‚ÇÇ f; apply h‚ÇÑ
    rw [h‚ÇÖ] at h‚ÇÜ
    rw [h‚ÇÖ]
    apply eisensteinSubspace_vanishing_is_zero hk a
    apply EisensteinSeries_in_EisensteinSubspace c hk a
    apply h‚ÇÜ
  ¬∑ unfold Codisjoint
    intro x h‚ÇÅ h‚ÇÇ
    sorry

instance id‚ÑÇ : ‚ÑÇ ‚âÉ* ‚ÑÇ where
  toFun := fun z ‚Ü¶ z
  invFun := fun z ‚Ü¶ z
  left_inv := by tauto
  right_inv := by tauto
  map_mul' := by tauto

lemma idinj : Bijective id‚ÑÇ := by apply id‚ÑÇ.bijective
#check MulEquiv.refl

--¬´ ;) ¬ª
lemma rank_ModulaForm_equiv_prod (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
Module.rank ‚ÑÇ ((Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) √ó (CuspForm_Subspace Œì((1 : ‚Ñï+)) k))
= Module.rank ‚ÑÇ (ModularForm Œì(‚Üë1) k) := by
  apply rank_eq_of_equiv_equiv id‚ÑÇ (LinearEquiv.toAddEquiv (Submodule.prodEquivOfIsCompl (Submodule.span ‚ÑÇ {(eisensteinSeries_MF hk a : (ModularForm Œì((1 : ‚Ñï+)) k))}) (CuspForm_Subspace Œì((1 : ‚Ñï+)) k)  (eisensteinSeries_comp_CuspForm hk a) ) )
  apply idinj
  intro r m
  simp [id‚ÑÇ]

lemma rank_eisensteinSubspace_one (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
 Module.rank ‚ÑÇ ‚Ü•(Submodule.span ‚ÑÇ {eisensteinSeries_MF hk a}) = 1 := by
  rw [rank_submodule_eq_one_iff]
  use eisensteinSeries_MF hk a
  constructor
  ¬∑ unfold Submodule.span
    simp
  constructor
  ¬∑ apply Eisenstein_series_not_zero
  ¬∑ tauto

theorem dimen (hk : 3 ‚â§ k) (a : Fin 2 ‚Üí ZMod (1 : ‚Ñï+)) :
Module.rank ‚ÑÇ (ModularForm Œì(1) k) = Module.rank ‚ÑÇ (CuspForm_Subspace Œì(1) k) + 1 := by
  rw [‚Üê rank_ModulaForm_equiv_prod hk a, rank_prod',add_comm, rank_eisensteinSubspace_one]
  rfl
